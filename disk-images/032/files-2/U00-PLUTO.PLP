procedure initialise;
begin
  repeat until port[status]>127;
  for i:=1 to 4 do
    port[status]:=0;
  repeat until port[status]>127;
  port[data]:=init_;
end;

procedure hires;
begin
 repeat until port[status]>127;
 port[data]:=$AA;
end;

procedure setcwp(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=scwp_;
  repeat until port[status]>127;
  port[data]:=c;
end;

 procedure setcdp(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=scdp_;
  repeat until port[status]>127;
  port[data]:=c;
end;

procedure moveto(xc,yc : integer);
begin
  repeat until port[status]>127;
  port[data]:=mto_;
  repeat until port[status]>127;
  port[data]:=lo(xc);
  port[data]:=hi(xc);
  port[data]:=lo(yc);
  port[data]:=hi(yc);
end;

procedure sccol(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=sccol_;
  repeat until port[status]>127;
  port[data]:=c;
end;

procedure sstle(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=sstle_;
  repeat until port[status]>127;
  port[data]:=c;
end;

procedure lto(x,y : integer);
begin
  repeat until port[status]>127;
  port[data]:=lto_;
  repeat until port[status]>127;
  port[data]:=lo(x);
  port[data]:=hi(x);
  port[data]:=lo(y);
  port[data]:=hi(y);
end;


procedure ffill;
begin
  repeat until port[status]>127;
  port[data]:=ffill_;
end;

 procedure sfcol(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=sfcol_;
  repeat until port[status]>127;
  port[data]:=c;
end;


 procedure sbcol(c : byte);
begin
  repeat until port[status]>127;
  port[data]:=sbcol_;
  repeat until port[status]>127;
  port[data]:=c;
end;


procedure rsel(x : integer);
begin
 repeat until port[status]>127;
 port[data]:=$B8;
 repeat until port[status]>127;
  port[data]:=x;
end;

procedure wprot(x : integer);
begin
  repeat until port[status]>127;
  port[data]:=$8C;
  repeat until port[status]>127;
  port[data]:=x;
end;

PROCEDURE dump_pluto(xx1,yy1 : integer);
type
  bitarray=array[1..388] of boolean;
var i,c : integer;
 eight : array[1..588] of byte;
 finish,
 the_end,
 e,
 e1 : boolean;
 line, crl : integer;
 sixpos, lastdata : integer;
 oddline, evenline : bitarray;
 arraypos, binpos : integer;
 bt : integer;
 result,tb : byte;
 end_one, end_two,last_line : integer;
 dots,
 start,
 remainder,
 bitcount,
 xc,yc, Lcount : integer;

procedure place(b : byte);
begin
  sixline[sixpos]:=b;
  if (sixpos=128) or (finish=TRUE) then
  begin
    blockwrite(fname,sixline,1);
    sixpos:=1;
    fillchar(sixline,sizeof(sixline),0);
  end
  else
  sixpos:=sixpos+1;
end; {of place}

procedure convert_to_six(Var a : bitarray);
var
  temp : byte;
begin
  arraypos:=1;
  repeat
    temp:=64;
     if a[arraypos] then temp:=temp or 1;
     if a[arraypos+1] then temp:=temp or 2;
     if a[arraypos+2] then temp:=temp or 4;
     if a[arraypos+3] then temp:=temp or 8;
     if a[arraypos+4] then temp:=temp or 16;
     if a[arraypos+5] then temp:=temp or 32;
    place(temp);
    arraypos:=arraypos+6;
  until arraypos>=binpos;
end;  {of convert_to_six}


begin    {dump_pluto}
  if bdr=FALSE then rsel(green) else rsel(white);
  sixpos:=1; lastdata:=0;
  last_line:=yy1;
  start:=xx1-(xx1 mod 8)+8;
  finish:=FALSE;
  Fillchar(oddline,yy1 div 2,0);
  Fillchar(evenline,yy1 div 2,0);
  Fillchar(eight,yy1,0);
  REPEAT
   sccol(red);
   start:=start-8;
   if start<0 then
   begin
     finish:=TRUE;
     place($1a);
   end
   else
   begin
     moveto(start,0);
     repeat until port[status]>127;
     port[data]:=$BE;
     repeat until port[status]>127;
     port[data]:=lo(8);
     port[data]:=hi(8);
     port[data]:=lo(yy1+2);
     port[data]:=hi(yy1+2);
     gotoxy(54,8);
     write((xx1-start)/xx1*100:4:0,' % done.');clreol;
{Read one row of bytes from Pluto}
     for count:=1 to yy1+3 do
        eight[count]:=port[data];

{for each bit in turn, LSBF or lowest remainder bit,
 check each byte for that bit and put T or F into two boolean arrays,
 one for the odd bytes and one for the even}
     bitcount:=1;
     repeat
      count:=1; lcount:=1;
      repeat
                   {The first byte's bit goes into oddline[1],
                   the second byte's bit goes into evenline[1] }

         e:=(eight[count] and bitcount) > 0;
         e1:=(eight[count+1] and bitcount) > 0;

         evenline[Lcount]:=e;
         oddline[Lcount]:=e1;

         if e or e1 then
          lastdata:=count;

         count:=count+2;
         Lcount:=Lcount+1
      until count>=yy1+2;
{If line contains no data then send a blank else;
 these two boolean arrays now have to be converted into bytes
 for the printer. Do odd first, take six bits, invert them, add 64
 then send it!!!!!}
      if lastdata =0 then
      begin
       place(5); place(64); place(13); place(10);
      end
      else
      begin
       binpos:=(yy1+2) div 2;  (* was = round(lastdata/6+0.17)*6;*)
       place(4);
       convert_to_six(oddline);
       if number_across>1 then
       for count:=2 to number_across do
       begin
         for dots:=1 to space_between_labels do
          place(64);
         convert_to_six(oddline);
       end;
       place(13); place(10); place(5);
       convert_to_six(evenline);
       if number_across>1 then
       for count:=2 to number_across do
       begin
         for dots:=1 to space_between_labels do
          place(64);
         convert_to_six(evenline);
       end;
       place(13); place(10);
      end;
      bitcount:=bitcount shl 1;    {Multiple by 2}
      lastdata:=0;
      Fillchar(oddline,sizeof(oddline),0);
      Fillchar(evenline,sizeof(evenline),0);
     until bitcount=256;
     Fillchar(eight,sizeof(eight),0);
   end;  {of if start not <0 }
      { End of one column from Pluto, go get another unless its The End. }
  UNTIL finish=TRUE;
end; {of dump_pluto}



procedure output(VAR ch : byte);
begin
  inline($DB/$B4/    {IN A,B4}
         $1F/        {RRA}
         $38/$FB/    {JR,C }
         $2A/ch/     {LD HL,(CH)}
         $7E/        {LD A,(HL)}
         $D3/$B5/    {OUT (B5),A}
         $AF/        {XOR A}
         $D3/$B4/    {OUT (B4),A}
         $3C/$3C/    {INC A INC A}
         $D3/$B4     {OUT (B4),A}
);
end;
