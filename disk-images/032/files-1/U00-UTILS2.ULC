(*  ConstStr returns a string with N characters of value C *)

function ConstStr(C : Char; N : Integer) : Str125;
var
  S : str125;
begin
  if N < 0 then
    N := 0;
  S[0] := Chr(N);
  FillChar(S[1],N,C);
  ConstStr := S;
end;

PROCEDURE getinput(maxnum : integer;
                ac,dn : integer;
                VAR line : str125;
                kind : char;
                VAR fin : boolean;
                start : integer);

      (* Requires global var INST:BOOLEAN set TRUE for INSERT Mode
         or FALSE for OVERWRITE Mode *)

label exit;

const Underscore = '_';

var
    dec,done : boolean;
    pos, xadj, yadj : integer;



procedure printchar;
begin
 if pos<=maxnum then
 begin
     if length(line)=maxnum then
       delete(line,maxnum,1);
     if inst=TRUE then
      insert(ans,line,pos)
     else
     begin
      if pos>length(line) then
       line:=line+' ';
      line[pos]:=ans;
     end;
     gotoxy(ac,dn);write(line,ConstStr(Underscore,Maxnum-length(line)));
     IF pos<maxnum THEN
       pos:=succ(pos);
 end;
end;

BEGIN
 dec:=FALSE;
 for pos:=1 to length(line) do
   if line[pos]='.' then
    dec:=TRUE;
 fin:=FALSE;
 done:=FALSE;
 up:=FALSE;
 down:=FALSE;
 if start>maxnum THEN start:=maxnum;
 ans:=' ';
 pos:=start;
 gotoxy(65,8);
 lowvideo;
 write('Insert Mode'); clreol;
 normvideo;
 gotoxy(ac,dn);write(line,ConstStr(Underscore,Maxnum-length(line)));

 REPEAT
 if pos>80 then
 begin
   xadj:=80; yadj:=1;
 end
 else
 begin
   xadj:=0; yadj:=0;
 end;
 gotoxy(ac+pos-1-xadj,dn+yadj);read(kbd,ans);
 IF ans IN [esc,cul,cur,cup,cud,ins,del,cr,bs,ch,^G,^A,^F,^V] THEN
   begin
     CASE ans OF
       esc : begin
              fin:=TRUE;
              goto exit;
             end;

      cr     : begin
                done:=TRUE;
                goto exit;
               end;

    cup,cud : begin
              done:=true;
              IF (ans=cup)and(noup=FALSE) THEN
              begin
               up:=TRUE;
               goto exit;
              end;
              IF (ans=cud)and(nodown=FALSE) THEN
              begin
               down:=TRUE;
               goto exit;
              end;
              done:=FALSE;
             end;

       cul : IF pos>1 THEN
             begin
              pos:=pred(pos);
              gotoxy(ac+pos-1,dn);
             end;

       cur : IF pos<=length(line) THEN
              begin
                pos:=succ(pos);
                gotoxy(ac+pos-1,dn);
              end;

       ins : begin
                insert(' ',line,pos);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
               end;

       del,^G : begin
                if line[pos]='.' then
                  dec:=FALSE;
                delete(line,pos,1);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
               end;

        ch : begin
               write(ConstStr(Underscore,length(line)-pos+1));
               Delete(line,pos,maxnum);
             end;
        bs : IF pos<>1 THEN
              begin
                IF line[pos-1]='.' THEN
                  dec:=FALSE;
                delete(line,pos-1,1);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
                pos:=pred(pos);
              end;
        ^A : pos:=1;
        ^F : pos:=length(line)+1;
        ^V : begin
              inst:=not inst;
              gotoxy(65,8);
              lowvideo;
              case inst of
              TRUE : write('Insert Mode');
              False: write('Overwrite Mode');
              end;
              normvideo;
              clreol;
             end;
     end; {of CASE }
   end
 ELSE
 begin

 CASE kind OF

   'a' : IF ans IN [' '..'/',':'..'~'] THEN
             printchar;

   'n' : IF ans IN ['0'..'9','-','.'] THEN

           Case ans of
             '0'..'9' :  printchar;

             '-' :  IF pos=1 THEN printchar;

             '.' : IF not dec THEN
                   begin
                    printchar;
                    dec:=TRUE;
                   end;
           end; {of case}

  'b' : IF ans IN [' '..'~'] THEN
                printchar;

  'c' : IF ans IN [' '..'~'] THEN
         begin
           IF ans IN ['a'..'z'] THEN
            ans:=chr(ord(ans)-$20);
           printchar;
         end;

  's' : IF ans IN ['A'..'Z','0'..'9','a'..'z','%','.',':','-',' ','/'] THEN
         begin
           IF ans IN ['a'..'z'] THEN
            ans:=chr(ord(ans)-$20);
           printchar;
         end;

 end; {of case}
 end;
exit:
 if ans in [cr,esc] then
 begin
  gotoxy(ac,dn);
  write(line,ConstStr(' ',Maxnum-length(line)));
 end;
UNTIL fin or done;

Case ans of
cup,cud :   IF ((ans=cup)and(noup=FALSE))or((ans=cud)and(nodown=FALSE))THEN
              done:=TRUE;

       esc : begin
               fin:=TRUE;
             end;

 end;  {of case}
 gotoxy(65,8); clreol;
END; {of getinput}


procedure scalefont;
var
  m,t : integer;
  i,j : integer;

begin
if (scl<>1.0) and (fontname<>'NONE') then
 begin
  for i:=1 to 95 do
  begin
    num:=lo(vecary[i][0]);
    for j:=1 to num do
    begin
      t:=vecary[i][j];
      m:=hi(t) and 128;
      vecary[i][j]:=(round((hi(t)-m)*scl)+m) shl 8 +round(lo(t)*scl);
    end;
  end;
 end;
 set_jump;
end;  {of scalefont}

procedure loadfont;
begin
  {$I-} reset(cf); {$I+}
  if ioresult=0 then
  begin
    read(cf,vector);
    base:=vector[0];
    scalbase:=round(base*scl);
    for i:=1 to 95 do
     read(cf,vecary[i]);
  end
  else
  begin
   gotoxy(25,8);lowvideo;Write(fontname,' DOES NOT EXIST. ');
   normvideo; clreol;
   delay(3000);
   fontname:='NONE';
  end;
end;

procedure fontchange;
begin
  gotoxy(1,8);write('Font Name: ');clreol;
  fontname:='';
  getinput(10,12,8,fontname,'c',fin,1);
  assign(cf,labeldrive+fontname+'.CHR');
  gotoxy(25,8);write('Loading Font, please wait...');
  loadfont;
  if fontname<>'NONE' then
   scalefont;
  key_info(5,CurrentFt);
  options;
end; {of fontchange}

procedure scalechange;
var
 j : integer;
begin
 repeat
  gotoxy(1,8);write('Scale: ');clreol;
  tempstr:='';
  getinput(3,8,8,tempstr,'n',fin,1);
  val(tempstr,scl,j);
 until j=0;
  key_info(5,CurrentSc);
  gotoxy(1,8);write('Re-Scaling Font. Please wait... ');clreol;
  scalefont;
  scalbase:=round(base*scl);
  options;
end; {of scalechange}

procedure penchange;
begin
  for i:=15 to 25 do
  begin
    gotoxy(1,i);clreol;
  end;
  options;

  gotoxy(1,15); write('Pen shapes available:');
  gotoxy(1,17); write('1.  *');
  gotoxy(1,19); write('     *');
  gotoxy(1,20); write('2.  ***');
  gotoxy(1,22); write('    **');
  gotoxy(1,23); write('3.  **');
  gotoxy(1,25); write('4.  ***');
  repeat
   gotoxy(1,8);write('Pen: ');clreol;
   tempstr:='';
   getinput(1,6,8,tempstr,'n',fin,1);
   val(tempstr,curpen,j);
  until curpen in [1..4];
  key_info(5,CurrentPn);
  case curpen of
   1 : penwidth:=1;
   2 : penwidth:=3;
   3 : penwidth:=2;
   4 : penwidth:=3;
  end; {of case}
  set_jump;
  clrframe(15,25);
  options;
end; {of penchange}

procedure check_cursor;
begin
  if cx<left+5 then cx:=left+5;
  if cx>right-5 then cx:=right-5;
  if cy<top+4 then cy:=top+4;
  if cy>bottom-4 then cy:=bottom-4;
end;

Procedure remove_cursor;
begin
if areanum>0 then
 begin
  sstle(6);
  sccol(cyan);
  check_cursor;
  moveto(cx-5,cy);
  lto(cx+5,cy);
  moveto(cx,cy-4);
  lto(cx,cy-1);
  moveto(cx,cy+1);
  lto(cx,cy+4);
  sstle(0);
 end;
end;

procedure put_cursor;
begin
if areanum>0 then
 begin
  sstle(4);
  sccol(red);
  cx:=cx+cx1;
  cy:=cy+cy1;
  check_cursor;
  moveto(cx-5,cy);
  lto(cx+5,cy);
  moveto(cx,cy-4);
  lto(cx,cy-1);
  moveto(cx,cy+1);
  lto(cx,cy+4);
  moveto(cx,cy);
  sstle(0);         {standard mode}
 end;
end;



procedure setkeys;
begin
  write(chr(27),'f');
  write(chr($81),^L);
  write(chr($82),^A);
  write(chr($83),^F);
  write(chr($84),^S);
  write(chr($85),^P);
  write(chr($86),^T);
  write(chr($87),^E);
  write(chr($88),^Q);
  write(chr($89),^X);
  write(chr($8A),'a');
  write(chr($8B),''); {Disable EDIT key}
  write(chr($C0));
 end;

Procedure write_it(s : str255);

procedure print;
begin
   ac:=charsize; dn:=0;
   if ord(s[1])-31>0 then
   for l:=1 to length(s) do
   begin
     vector:=vecary[ord(s[l])-31];
     num:=lo(vector[0]);
      for j:=1 to num do
      begin
        inp:=vector[j];
        ac:=hi(inp); dn:=lo(inp);
        if (ac and 128)>0 then
        begin
          ac:=ac-128;
          moveto(cx+ac,cy-dn);
        end
        else
        begin
          lto(cx+ac,cy-dn);
        end;
      end;
      cx:=cx+ac+penwidth;
   end;
   cx:=tx; cy:=ty+scalbase;

end;  {of print in write_it}

begin
   cy:=cy+scalbase;
   case curpen of
   1 : print;
   2 : begin
        print;
        cx:=cx+1; print;
        cx:=cx+2; print;
        cx:=cx+1; cy:=cy-1; print;
       end;
   3 : begin
        print;
        cx:=cx+1; print;
        cx:=cx+1; cy:=cy-1; print;
        cy:=cy-1; print;
       end;
   4 : begin
        print;
        cx:=cx+1; print;
        cx:=cx+2; print;
       end;
   ELSE begin
         curpen:=1; print;
        end;
   end; {of case}
end; {of write_it}

Procedure breakline(ll : str255);
var
  last, numchar : integer;
  ts : str125;  {temp string}
begin
   error:=0; breaknum:=1;
   sx:=cx; sy:=cy; {Start pos of first line}
   tx:=cx; ty:=cy; {Temporary Vars for line start}
   charsize:=round(16*scl)+penwidth;
   repeat
        {Get number of possible chars on line}
     numchar:=round((right-cx+round(scl))/charsize);

     if numchar<length(ll) then   {Are there too many?}
     begin                       {Yes, so split line up}
       last:=numchar;
       breaknum:=breaknum+1;
       while ll[last]<>' ' do
       begin
         last:=last-1;
        if last<1 then
        begin
         gotoxy(1,8);
         if length(ll)<59 then
         begin
          if iccol<>black then
          begin
           lowvideo; write(ll,' is too long for line.');normvideo;
          end;
         end
         else
         begin
          if iccol <> black then
          begin
           lowvideo; write('This is too long for the line.');normvideo;
          end;
         end;
         clreol;
         delay(3000);
         cx:=sx; cy:=sy;
           ll:=copy(tl,1,length(tl)-length(ll));
           breakline(ll);
         error:=1;
         exit;
        end;
       end;
       ts:=copy(ll,1,last);
       write_it(ts);
       cx:=left+5;
       tx:=cx;
       cy:=ty+round(20*scl);
       ty:=cy;
       ll:=copy(ll,last+1,length(ll))
     end
     else                        {No. So do whole line}
     begin
       write_it(ll);
       ll:='';
     end;
   until length(ll)=0;
   cx:=sx; cy:=sy;  {Restore start of line}
   moveto(cx,cy);   {and move to it}
end;  {of breakline}


procedure show_function_line;
begin
  lowvideo;
  gotoxy(1,3);write(' F0 ');
  gotoxy(9,3);write(' F1 ');
  gotoxy(17,3);write(' F2 ');
  gotoxy(25,3);write(' F3 ');
  gotoxy(33,3);write(' F4 ');
  gotoxy(41,3);write(' F5 ');
  gotoxy(49,3);write(' F6 ');
  gotoxy(57,3);write(' F7 ');
  gotoxy(65,3);write(' F8 ');
  gotoxy(73,3);write(' F9 ');
  normvideo;
end; {show_function_line}


procedure setup;
begin
 initialise;
 sstle(0);
 fontname:='ME2';
 assign(cf,labeldrive+fontname+'.CHR');
 {$I-} reset(cf); {$I+}
 if ioresult<>0 then
 begin
   gotoxy(1,8);
   write('CAUTION. The Standard font ME2 is not on drive ',labeldrive);
   delay(4000);
 end;
 labname:='NONE';
 areanum:=0;
 cx1:=0; cy1:=0;
 scl:=0.5; curpen:=1;
 left:=0; right:=767;
 top:=0; bottom:=287;
 display_label_area;
 tempstr:='';
 tl:='';
 penwidth:=1;
 opmode:=non;
 txtmode:='S';
 loadfont;
 scalefont;
 inst:=TRUE;
end;

Procedure delete_symbol(sn : str14);
begin
   assign(sf,labeldrive+sn+'.SYM');
   {$I-} reset(sf); {$I+}
   if ioresult>0 then
   begin
     gotoxy(1,8);
     write('File for Symbol ',sn,' not on current drive');
     delay(3000);exit;
   end;
   while not eof(sf) do
   begin
     read(sf,symvec);
     if symvec.status<>0 then
     with symvec do
      draw_vector(startx,starty,endx,endy,black);
   end;
   close(sf);
end; {of delete_symbol}

Procedure put_symbol(sn : str14);
begin
   assign(sf,labeldrive+sn+'.SYM');
   {$I-} reset(sf); {$I+}
   if ioresult>0 then
   begin
     gotoxy(1,8);
     write('File for Symbol ',sn,' not on current drive');
     delay(3000);exit;
   end;
   while not eof(sf) do
   begin
     read(sf,symvec);
     if symvec.status<>0 then
     with symvec do
      draw_vector(startx,starty,endx,endy,green);
   end;
   close(sf);
end;

Procedure Temp_symbol(sn : str14);
begin
   assign(sf,labeldrive+sn+'.SYM');
   {$I-} reset(sf); {$I+}
   ir:=ioresult;
   if ir>0 then
   begin
     gotoxy(1,8);
     write('File for Symbol ',sn,' not on current drive');
     delay(3000);exit;
   end;
   while not eof(sf) do
   begin
     read(sf,symvec);
     if symvec.status<>0 then
     with symvec do
      draw_vector(startx,starty,endx,endy,red);
   end;
   close(sf);
end;
