PROCEDURE display_files(ext : str3; dn : integer; drv : char);
Var
  dma : string[129]; {Location to store portion of DIR read in}
  filename : string[12];
  fcb : array[1..12] of byte absolute $5c;  {Location filename is stored}
  x,j,entry,count :integer;
  prog : string[12];
  drivenum : char;
  xx : FILE;

procedure printit;                    {x = the number (0 - 3) of the}
 begin                                {entry in the DMA. Each entry }
   entry:=(x*32)+1;                   {uses 32 bytes. The first 12  }
   prog:=copy(dma,entry+1,8);         {give the drive, name & extension.}
   write(prog:10);
 end;


BEGIN
assign(xx,drv+':Z.Z'); close(xx);
dma:='';
for j:=1 to 129 DO
  dma:=dma+' ';
drivenum:=chr(ord(drv)-$40);
gotoxy(5,dn);
 filename:='????????'+ext;
 fcb[1]:=ord(drivenum);             {First byte indicates drive, 0=A etc.}
 for x:=2 to 12 do
  fcb[x]:=ord(filename[x-1]);  {Put filename in fcb}
 x:=bdos($1a,addr(dma)+1);     {Tell CP/M where to put portion of DIR}
                               {First byte of a string address contains}
                               {its length. }
 x:=bdos($11,$5c);             {Find first entry}
 if x<>255 THEN                {If x=255 then no entry found}
 begin
   printit;
   count:=1;                   {Set up count to print 4 on a line}
   repeat
     if count MOD 7=0 THEN     {If 7 printed do a linefeed}
     begin
      writeln;write('    ');
      IF count MOD (24-dn)*7=0 THEN   {If max lines start again}
      begin
        write('Press any key to display more, or <ESC> to select.');
        read(kbd,ans);
        if ans=#27 then exit;
        for k:=0 to 24-dn do
        begin
          gotoxy(1,dn+k);clreol;
        end;
        gotoxy(5,dn);
      end;

     end;
     x:=bdos($12);             {Find next entry ......}
     if x<>255 THEN
      printit;
     count:=count+1;
   until x=255;                {.... until no more found}
 end
 ELSE
 begin
   gotoxy(1,10);
   write('No files of extension ',ext,' found on drive ',drv,'.');
 end;
END;



procedure ready;
var
  by : byte;
begin
 repeat
  by:=port[status] and 128;
 until by=128;
end;

procedure initialise;
var
  i : integer;
begin
  ready;
  for i:=1 to 4 do
    port[status]:=0;
  ready;
  port[data]:=init_;
end;

procedure moveto(xc,yc : integer);
begin
  if xc<left+1 then xc:=left+1;
  if xc>right-1 then xc:=right-1;
  if yc<top+1 then yc:=top+1;
  if yc>bottom-1 then yc:=bottom-1;
  ready;
  port[data]:=mto_;
  ready;
  port[data]:=lo(xc);
  port[data]:=hi(xc);
  port[data]:=lo(yc);
  port[data]:=hi(yc);
end;

procedure sccol(c : byte);
begin
  ready;
  port[data]:=sccol_;
  ready;
  port[data]:=c;
end;

procedure sstle(c : byte);
begin
  ready;
  port[data]:=sstle_;
  ready;
  port[data]:=c;
end;

procedure lto(x,y : integer);
begin
  if x<left+1 then x:=left+1;
  if x>right-1 then x:=right-1;
  if y<top+1 then y:=top+1;
  if y>bottom-1 then y:=bottom-1;
  ready;
  port[data]:=lto_;
  ready;
  port[data]:=lo(x);
  port[data]:=hi(x);
  port[data]:=lo(y);
  port[data]:=hi(y);
end;


procedure ffill;
begin
  ready;
  port[data]:=ffill_;
end;

 procedure sfcol(c : byte);
begin
  ready;
  port[data]:=sfcol_;
  ready;
  port[data]:=c;
end;


 procedure sbcol(c : byte);
begin
  ready;
  port[data]:=sbcol_;
  ready;
  port[data]:=c;
end;

 procedure setcwp(c : byte);
begin
  ready;
  port[data]:=scwp_;
  ready;
  port[data]:=c;
end;

 procedure setcdp(c : byte);
begin
  ready;
  port[data]:=scdp_;
  ready;
  port[data]:=c;
end;


procedure rsel(x : integer);
begin
 ready;
 port[data]:=$B8;
 ready;
  port[data]:=x;
end;

procedure wprot(x : integer);
begin
  ready;
  port[data]:=$8C;
  ready;
  port[data]:=x;
end;

procedure clrframe(s,f : integer);
var i : integer;
begin
  for i:=s to f do
  begin
   gotoxy(1,i);
   clreol;
  end;
end;

procedure display_edit_options;
begin
  gotoxy(10,20);
  write('^A = Start of line. ^F = End of line. ^V = Toggle Insert on/off.');
  gotoxy(10,21);
  write('^Y = Kill to end of line. Del = Delete character to right.');
  gotoxy(10,22);
  write('Back Space Deletes character to left and moves cursor.');
  gotoxy(10,23);
  write('Left & Right cursor arrows move one character at a time.');
end;

procedure kill_edit_options;
var
 i : integer;
begin
 for i:=20 to 23 do
 begin
   gotoxy(1,i);clreol;
 end;
end;


(*  ConstStr returns a string with N characters of value C *)

function ConstStr(C : Char; N : Integer) : Str125;
var
  S : str125;
begin
  if N < 0 then
    N := 0;
  S[0] := Chr(N);
  FillChar(S[1],N,C);
  ConstStr := S;
end;

PROCEDURE getinput(maxnum : integer;
                ac,dn : integer;
                VAR line : str125;
                kind : char;
                VAR fin : boolean;
                start : integer);

label exit;

const Underscore = '_';

var
    inst,dec,done : boolean;
    pos, xadj, yadj : integer;



procedure printchar;
begin
 if pos<=maxnum then
 begin
     if length(line)=maxnum then
       delete(line,maxnum,1);
     if inst=TRUE then
      insert(ans,line,pos)
     else
     begin
      if pos>length(line) then
       line:=line+' ';
      line[pos]:=ans;
     end;
     gotoxy(ac,dn);write(line,ConstStr(Underscore,Maxnum-length(line)));
     IF pos<maxnum THEN
       pos:=succ(pos);
 end;
end;

BEGIN
 dec:=FALSE; inst:=FALSE;
 for pos:=1 to length(line) do
   if line[pos]='.' then
    dec:=TRUE;
 fin:=FALSE;
 done:=FALSE;
 up:=FALSE;
 down:=FALSE;
 if start>maxnum THEN start:=maxnum;
 ans:=' ';
 pos:=start;
 gotoxy(65,8);
 lowvideo;
 write('Insert Mode'); clreol;
 normvideo;
 gotoxy(ac,dn);write(line,ConstStr(Underscore,Maxnum-length(line)));

 REPEAT
 if pos>80 then
 begin
   xadj:=80; yadj:=1;
 end
 else
 begin
   xadj:=0; yadj:=0;
 end;
 gotoxy(ac+pos-1-xadj,dn+yadj);read(kbd,ans);
 IF ans IN [esc,cul,cur,cup,cud,ins,del,cr,bs,ch,'?',^G,^A,^F,^V] THEN
   begin
     CASE ans OF
       esc : begin
              fin:=TRUE;
              goto exit;
             end;

      cr,'?' : begin
                done:=TRUE;
                goto exit;
               end;

    cup,cud : begin
              done:=true;
              IF (ans=cup)and(noup=FALSE) THEN
              begin
               up:=TRUE;
               goto exit;
              end;
              IF (ans=cud)and(nodown=FALSE) THEN
              begin
               down:=TRUE;
               goto exit;
              end;
              done:=FALSE;
             end;

       cul : IF pos>1 THEN
             begin
              pos:=pred(pos);
              gotoxy(ac+pos-1,dn);
             end;

       cur : IF pos<=length(line) THEN
              begin
                pos:=succ(pos);
                gotoxy(ac+pos-1,dn);
              end;

       ins : begin
                insert(' ',line,pos);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
               end;

       del,^G : begin
                if line[pos]='.' then
                  dec:=FALSE;
                delete(line,pos,1);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
               end;

        ch : begin
               write(ConstStr(Underscore,length(line)-pos+1));
               Delete(line,pos,maxnum);
             end;
        bs : IF pos<>1 THEN
              begin
                IF line[pos-1]='.' THEN
                  dec:=FALSE;
                delete(line,pos-1,1);
                gotoxy(ac,dn);
                write(line,ConstStr(Underscore,Maxnum-length(line)));
                pos:=pred(pos);
              end;
        ^A : pos:=1;
        ^F : pos:=length(line)+1;
        ^V : begin
              inst:=not inst;
              gotoxy(65,8);
              lowvideo;
              case inst of
              TRUE : write('Insert Mode');
              False: write('Overwrite Mode');
              end;
              normvideo;
              clreol;
             end;
     end; {of CASE }
   end
 ELSE
 begin

 CASE kind OF

   'a' : IF ans IN [' '..'/',':'..'~'] THEN
             printchar;

   'n' : IF ans IN ['0'..'9','-','.'] THEN

           Case ans of
             '0'..'9' :  printchar;

             '-' :  IF pos=1 THEN printchar;

             '.' : IF dec=FALSE THEN
                   begin
                    printchar;
                    dec:=TRUE;
                   end;
           end; {of case}

  'b' : IF ans IN [' '..'~'] THEN
                printchar;

  'c' : IF ans IN [' '..'~'] THEN
         begin
           IF ans IN ['a'..'z'] THEN
            ans:=chr(ord(ans)-$20);
           printchar;
         end;

  's' : IF ans IN ['A'..'Z','0'..'9','a'..'z','%','.',':','-',' ','/'] THEN
         begin
           IF ans IN ['a'..'z'] THEN
            ans:=chr(ord(ans)-$20);
           printchar;
         end;

 end; {of case}
 end;
exit:
UNTIL fin or done;

Case ans of
cup,cud :   IF ((ans=cup)and(noup=FALSE))or((ans=cud)and(nodown=FALSE))THEN
              done:=TRUE;

       esc : begin
               fin:=TRUE;
             end;

       '?' : IF kind='n' THEN
              query:=TRUE
             ELSE
             IF kind IN ['a'..'c'] THEN
             printchar;
 end;  {of case}
 gotoxy(65,8); clreol;
END; {of getinput}

