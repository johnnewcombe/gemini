 % ************************************************************************
 % ** COPYRIGHT.  STOIC-CP/M FILE HANDLING PROGRAMME FOR U.S.USERGROUP  ***
 % ** VERSION OF STOIC. A.R.M.CLARKE,CHILTON COTTAGE,SUDBURY,SUFFOLK    ***
 % ************************************************************************
 
% A.R.M.CLARKE. 1980

     RADIX @ DECIMAL

 % THIS IS A MEANS OF USING THE STANDARD STOIC AS FOUND ON THE U.S.USERGROUP
 % LIBRARY ,VOLUME 23.       IT GIVES A COMPLETE ACCESS TO THE CP/M B.D.O.S.
 % COMMANDS AND PROVIDES EVERYTHING NECESSARY FOR FILE HANDLING IN SEQUENTIAL
 % AND RANDOM ACCESS.  WITH THIS PROGRAMME IS A SLIGHTLY MODIFIED VERSION OF
 % THE STOIC SCREEN EDITOR TO PROVE THE POINT. TRY IT!
 % WHEREVER POSSIBLE ,COMPATIBILITY HAS BEEN MAINTAINED WITH THE STOIC FILE
 % HANDLING WORDS.  THE ORIGINAL KERNEL WORDS ARE NOT NEEDED BUT THE 'CPMLD'
 % COMMAND IS USED.COMMON UTILITIES SUCH AS TYPING THE FILE,COPYING,DELETING
 % AND RENAMING ARE IMPLEMENTED
 % PLEASE NOTE THAT I HAVE LEFT THE CODE RATHER UNECONOMIC IN SIZE OUT OF A
 % MIXTURE OF IDLENESS AND A DESIRE FOR CLARITY. IF YOU DEVISE A REVISION
 % THAT CONFORMS TO THE SPIRIT OF SPEED, CLARITY, AND ELEGANCE, LET ME KNOW
 % AND I WILL INCLUDE IT IN SUBSEQUENT REVISIONS.
 % THIS PACKAGE IS DESIGNED FOR CP/M 1.4 AND WILL NOT RUN ON CP/M 2.2 WITHOUT
 % MODIFICATION. PLEASE ALSO NOTE THAT, ALTHOUGH DRIVE SELECTION IS WRITTEN
 % INTO THE PACKAGE, I HAVE NOT DEBUGGED THIS AS I HAVE ONLY A SINGLE DISK
 % DRIVE. I HAVE RESISTED PUTTING IN TOO MANY WORDS (SUCH AS GETWORD-WHICH
 % GETS THE NEXT WORD STRING FROM THE FILE AND PUTS IT ON TOP OF THE
 % DICTIONARY) AS THE FILE IS ALREADY TOO LARGE AND YOU NEED SOME THINGS TO
 % PRACTICE ON; IF YOU GET STUCK, GIVE ME A RING ON SUDBURY(SUFFOLK) 76601
 % AND I WILL TRY TO HELP
 % P.S. MOST OF THIS WAS REVISED USING STOIC'S SCREEN EDITOR


 %            ****** CONSTANTS AND VARIABLES  ******

0       'FCBAD     VARIABLE   % POINTER TO CURRENT F.C.B.
0       'SFLAG     VARIABLE   % SEARCHFLAG FOR WILDCARD ACCESS
26      'EOF       CONSTANT   % CP/M'S END OF FILE CHARACTER
0       'DRIVE#    VARIABLE   % CURRENT DRIVE NUMBER (0-3)
128     'DMA       CONSTANT   % DEFAULT 'DMA' BUFFER
3942    'BLOCKBASE CONSTANT   % BASE ADDRESS OF THE LOWER BLOCK
% THIS IS AN UNASHAMED LASH-UP.  MODIFY IT TO SUIT THE KERNEL IMAGE 
-1      'CONS      VARIABLE   % OUTPUT TO CONSOLE FLAG
0       'LST       VARIABLE   % OUTPUT TO LIST DEVICE FLAG
0       'LASTBYTE  VARIABLE   % LAST BYTE OUTPUT BY STOIC
5       'BDOS      CONSTANT   % BDOS ENTRY POINT (0005H)
13      '<CR>      CONSTANT   % ASCII CARRIAGE RETURN
10      '<LF>      CONSTANT   % ASCII LINE FEED
19      '<^S>      CONSTANT   % CP/M STOP OUTPUT COMMAND

 %            ****** CONSOLE AND PRINTER OUTPUT ******

% THE FOLLOWING WORDS USE DIRECT BIOS CALLS RATHER THAN THE MORE OBVIOUS
% BDOS CALLS FOR TWO REASONS. TO GET UNECHOED INPUT AND BECAUSE I/O BDOS
% CALLS ARE NOTICABLY SLOWER!

% BIOS OFFSET IN DE, MAKES JUMP TO BIOS VECTOR TABLE
ASSEMBLER<
. 1 LHLD, D DAD, PCHL,
'BIOS CONSTANT

% 0/0   STOP? IS A SUBROUTINE THAT IMPLEMENTS THE USE OF ^S AS A MEANS OF
 % TEMPORARILY STOPPING OUTPUT TO THE PRINTER OR CONSOLE. ANY KEY PRESSED
 % WILL CAUSE OUTPUT TO CONTINUE
 
. 3 D LXI, BIOS CALL, A ANA, RZ, 6 D LXI, BIOS CALL,
<^S> CPI, RNZ, 6 D LXI, BIOS CALL, RET,
'STOP? CONSTANT

 % 0/0   (CLO) IS THE SUBROUTINE THAT IS THE CORE OF THE CP/M OUTPUT
 % MODS. OUTPUT IS SENT TO CONSOLE OR LIST DEVICE OR BOTH ACCORDING
 % TO THE FLAGS `CONS` AND `LST`. THE CONTROL S SWITCH IS IMPLEMENTED
 % AND THE AWKWARD DIFFERENCES BETWEEN STOIC AND CP/M IN THEIR 
 % TREATMENT OF THE CR/LF SEQUENCE IS AVOIDED BY SENDING LF
 % AUTOMATICALLY AFTER CR BUT IGNORING THE LF THAT OCCURS DIRECTLY
 % AFTER CR SO AS TO AVOID DOUBLE LINE FEEDS

. PSW PUSH, STOP? CALL, PSW POP, A C MOV, LASTBYTE LDA, <CR> CPI,
 C A MOV, IFNZ, <LF> CPI, RZ, THEN, 32 CPI, IFM, COLUMN H LXI,
 M INR, THEN, LASTBYTE STA,  . A C MOV, . <L PSW PUSH, B PUSH,
 CONS LDA, A ANA, IFZ, 9 D LXI, BIOS CALL, THEN, B POP, LST LDA,
 A ANA, IFZ, 12 D LXI, BIOS CALL, THEN, PSW POP, <CR> CPI, RNZ,
 A SUB, COLUMN STA, <LF> A MVI, JMP,
 >
'(CLO) CONSTANT

 % <CR.NO.LF> IS PART OF THE ROUTINE USED TO OUTPUT CARRIAGE RETURN
 % WITHOUT ACCOMPANYING LINE FEEDS
L> '<CR.NO.LF> CONSTANT

 % 1/0   <OUT> OUTPUTS THE BYTE AT TOP
'<OUT> CODE< H POP, L A MOV, (CLO) CALL, NEXT JMP, >

 % NOW WE MAKE (CLO) THE OFFICIAL OUTPUT ROUTINE
() <OUT> OUT !

 % AND NOW WHEN (TTO) IS CALLED, THEN (CLO) IS USED INSTEAD
ASSEMBLER<
(CLO) () (TTO) !
>

 % 0/0   CR(NO-LF) OUTPUTS A CR WITHOUT A LF
'CR(NO-LF) CODE< A SUB, COLUMN STA, <CR> C MVI, <CR.NO.LF> CALL, NEXT JMP, >

 % 1/0   LOU OUTPUTS BYTE ON TOP TO LIST DEVICE ONLY
'LOU : LST @ CONS @ LST -1<- CONS 0<- -ROT TYO CONS ! LST ! ;

 % 1/0   TOU OUTPUTS BYTE ON TOP TO CONSOLE ONLY
'COU : LST @ CONS @ LST 0<- CONS -1<- -ROT TYO CONS ! LST ! ;

 % 0/0   ^P SWITCHES THE PRINTER OUTPUT ON OR OFF
'^P : LST DUP @ NOT <- ;

 % NOW PRESSING CONTROL P SWITCHES PRINTER OUTPUT (IF SEPARATED FROM
 % ANOTHER STOIC WORD BY CR, SPACE, TAB OR FF)
'&020& : ^P ;

 %           ****** FILE CONTROL BLOCKS AND BUFFERS ******


 % FILE CREATES AN FCB WHOSE NAME IS AT TOP. WHEN REFERENCED 
 % THE ADDRESS OF THE FILE CONTROL BLOCK IS STORED IN THE
 % VARIABLE FCBAD. THIS CAUSES THE FILE CONTROL BLOCK TO BECOME
 % THE CURRENT ONE REFERENCED BY DISK FILE COMMANDS.
 % REMEMBER THAT THE STOICCPM SYSTEM USES AS MANY FILE CONTROL
 % BLOCKS AS NEEDED FOR FILE I/O. AS WELL AS THE CP/M BLOCK
 % IT ALSO HAS AN ARRAY CONTAINING FILE FLAGS AND VARIABLES
 % REQUIRED FOR COMPLEX FILE OPERATIONS. FINALLY, EACH FCB
 % HAS ITS OWN FILE BUFFER FOR FILE I/O SO THAT SEVERAL
 % FILES CAN BE WRITTEN TO OR READ FROM AT THE SAME TIME

'FILE : 17 3 64 + + SWAP ARRAY ;CODE< XCHG, FCBAD SHLD, NEXT JMP, >

 % FCB PUSHES THE ADDRESS OF THE CURRENT FILE CONTROL BLOCK
'FCB : FCBAD @ ;
 % FNAD PUSHES THE FILE NAME ADDRESS 
'FNAD CODE< 1 D LXI, . . . . . . . . . . . . FCBAD LHLD, D DAD, PUSH JMP, > 
 % FTAD PUSHES THE FILE TYPE ADDRESS 
'FTAD CODE< 9 D LXI, JMP, >
 % EX IS A VARIABLE GIVING FILE EXTENT 
'EX CODE< 12 D LXI, JMP, >
 % RC IS A VARIABLE GIVING THE RECORD COUNT
'RC CODE< 15 D LXI, JMP, >
 % NR IS A VARIABLE GIVING THE NEXT RECORD TO READ
'NR CODE< 32 D LXI, JMP, >
 % EF IS A FLAG THAT CAN BE SET TO NON-ZERO AT END OF FILE
'EF CODE< 33 D LXI, JMP, >
 % W/R IS A FLAG SHOW]NG THE WRITE/READ STATUS OF THE FILE 
'W/R CODE< 34 D LXI, JMP, > 
 % O/C IS A FLAG GIVING THE OPEN/CLOSED STATUS OF THE FILE 
'O/C CODE< 35 D LXI, JMP, > 
 % RB IS A VARIABLE THAT GIVES THE NEXT RELATIVE BYTE TO READ/ WRITE
'RB CODE< 36 D LXI, JMP, >
 % F/E IS A FLAG INDICATING WHETHER THE BUFFER IS EMPTY OR NOT
'F/E CODE< 37 D LXI, JMP, > 
 % DR# IS A VARIABLE GIVING THE DRIVE NO. OF THE FILE 
'DR# CODE< 38 D LXI, JMP, > 
 % R->BUF IS A VARIABLE GIVING THE CURRENT RECORD NO. IN THE BUFFER 
'R->BUF CODE< 39 D LXI, JMP, > 
 % FBUFFER PUSHES THE ADDRESS OF THE START OF THE FILE BUFFER 
'FBUFFER CODE< 40 D LXI, JMP, > 

 % NOW WE DEFINE THREE FCBS ! 
 'IFILE FILE   'OFILE FILE   'AFILE FILE   
             AFILE
% AFILE IS THE CURRENT FCB NOW


 %    ****** FILE CONTROL BLOCK WORDS. ******

 % 0/0  CLEARFCB CLEARS THE FCB AND PUTS IN BLANKS AND ZEROS
'CLEARFCB : FCB 84 0FILL FCB 6 8224 FILL 0 FCB B! ;

 % 1/2or3  FT-THERE? TAKES AN ADDRESS OF A STRING OFF THE STACK AND FINDS 
 % WHETHER THE STRING HAS A '.'  . IF SO IT CONVERTS THE FILENAME AND TYPE
 % INTO STOIC STRINGS AND PUSHES THEIR ADDRESS ON THE STACK. TOP OF THE
 % STACK CONTAINS A -1. IF NO '.'THE ADDRESS OF THE ENTIRE STRING IS
 % PUSHED AND AN 0 IS PUSHED ON THE TOP OF THE STACK
'FT-THERE? CODE< H POP, H D MOV, L E MOV, M B MOV, 0 C MVI,
 ASCII . A MVI, . <L H INX, M CMP, IFZ, C INR, B DCR, L> JNZ,
D PUSH, 0PUSH JMP, THEN, XCHG, M B MOV, B DCR, C M MOV, B A MOV,
C SUB, D STAX, H PUSH, D PUSH, -1PUSH JMP, >

 % 1/0 PUTINNAME PUTS THE FILENAME (AND OPTIONALLY THE TYPE) ADDRESSED
 % BY THE TOP OF THE STACK INTO THE CURRENT F.C.B.  IF NO FILETYPE IS
 % SPECIFIED THEN THE DEFAULT 'STC' FILETYPE IS INSERTED
'PUTINNAME : . 32 + SWAP DDUP B@ 1+ MVBYTES  FT-THERE? EQZ IF 
'STC THEN FTAD OVER 1+ FLIP B@ 3 MIN MVBYTES FNAD OVER 1+ FLIP
B@ 8 MIN MVBYTES ;

 % 1/0  INFCB CLEARS THE CURRENT FCB AND INSERTS THE FILENAME ADDRESSED
 % BY THE TOP OF THE STACK. IT ALSO MAKES THE DRIVE NUMBER THAT IS CURRENT
 % THE DRIVE NO. FOR THE FILE
'INFCB : CLEARFCB PUTINNAME DRIVE# @ DR# B! ;

 % 0/0  TYPEFCB TYPES THE FILENAME AND FILETYPE IN THE FCB 
'TYPEFCB : SPACE FNAD 8 + FNAD DO I B@ DUP 32 NE IF TYO ELSE DROP THEN 
LOOP 46 TYO FTAD 3 + FTAD DO I B@ DUP 32 NE IF TYO ELSE DROP THEN 
LOOP ;

 %            ****** ERROR MESSAGES ******

 % THESE MESSAGES ARE STORED AS NULL TERMINATED STRINGS PRECEEDED BY
 % THEIR BYTE COUNT SO THAT THEY CAN BE ACCESSED BY BOTH CODE AND FORTH
 % DEFINITIONS. THE STARTING ADDRESS OF EACH STRING IS STORED IN THE
 % ACCOMPANYING CONSTANT
 %        EG. 1ERROR MSG  OR 2ERROR ERR OR  4ERROR H LXI, ERROR JMP,

. "SORRY,BUT WE HAVE A PROBLEM.&15&THE " S, '0ERROR CONSTANT
. " FILE IS NOT ON" S, '1ERROR CONSTANT
. " FILE IS'NT OPEN" S, '2ERROR CONSTANT
. "D.O.S. READ PAST THE END OF THE FILE" S, '3ERROR CONSTANT
. "D.O.S. READ UNWRITTEN DATA IN RANDOM ACCESS" S, '4ERROR CONSTANT
. "ERROR WAS IN EXTENDING THE FILE" S, '5ERROR CONSTANT
. "END OF DISK DATA WAS REACHED" S, '6ERROR CONSTANT
. "DIRECTORY IS FULL UP !" S, '7ERROR CONSTANT
.  "FILE ALREADY EXISTS ON" S, '8ERROR CONSTANT

 %    ****** CP/M-FDOS INTERACTION WORDS ******


 % 2/1  (FUNCTION) (PARAMETER) FDOSENTRY,MAKES A BDOS CALL 
 % PUSHES RETURNED VALUE ON T.
'FDOSENTRY CODE<  D POP, B POP, BDOS CALL, 0 H MVI, A L MOV, PUSH JMP, >

 % 0/0  LIFTHEAD LIFTS THE HEAD FROM THE CURRENT DRIVE 
'LIFTHEAD : 12 0 FDOSENTRY DROP ;

 % 0/0  RESET SETS 80H DMA,INITIALIZES BDOS AND SELECTS DRIVE A  
'RESET : 13 0 FDOSENTRY DROP ;

 % 1/0  (DRIVENO.) LOGIN, LOGS IN AND SELECTS SPECIFIED DISC 
'LOGIN : 0 MAX 3 MIN 14 SWAP FDOSENTRY DROP ;

 % ?DRIVE ANNOUNCES THE DRIVE NO. 
'?DRIVE : 25 0 FDOSENTRY 32 TYO 65 + 32 'DRIVE MSG TYO TYO ;

 % 0/1  OPENFILE, OPENS THE FILE SPECIFIED IN THE FCB  
 % BYTE ADDRESS OF FCB IN DICTIONARY LEFT ON THE STACK  
'OPENFILE : 15 FCB FDOSENTRY DUP 255 EQ IF 0ERROR MSG TYPEFCB 1ERROR  
MSG ?DRIVE ABORT   THEN ;

 % 0/1  CLOSEFILE CLOSES A FILE THAT HAS PREVIOUSLY BEEN  
 % OPENED. LEAVES BYTE ADDRESS OF DIRECTORY FCB ON STACK  
'CLOSEFILE : 16 FCB FDOSENTRY DUP 255 EQ IF 0ERROR MSG 2ERROR 
ERR THEN ;

 % 0/1 OR 2  SEARCHFILE FINDS FIRST`OCCURECE` FCB IN   % THE DIRECTGRY . LEAVS BYTE ADDRESS ON STACK AT T-1 
 % AND -1 AT TOP . 0 AT TOP IF NO MATCH.  
'SEARCHFILE : 17 FCB FDOSENTRY DUP 255 EQ IF DROP  
0 ELSE -1 THEN ;

 % 0/1 OR 2  SEARCHAGAIN, USED AFTER SEARCHFILE WITH NO  
 % INTERMEDIATE BDOS CALLS .LEAVES BYTE ADDRESS AT T-1  
 % AND -1 AT TOP . 0 AT TOP IF NO MATCH.  
'SEARCHAGAIN : 18 FCB FDOSENTRY DUP 255 EQ IF DROP 0 
ELSE -1 THEN ;

 % 0/0  DELETEFILE WIPES FILE FROM THE DISC  
'DELETEFILE : 19 FCB FDOSENTRY DROP ;

 % 0/0  READARECORD READS THE NEXT RECORD OF A PREVIOUSLY  
 % OPENED FILE NR IS SET TO NEXT RECORD TO READ  
'READARECORD : 20 FCB FDOSENTRY DUP NEZ IF 0ERROR MSG 1 EQ IF 
3ERROR ERR ELSE 4ERROR ERR THEN THEN DROP ;

 % 0/0  WRITEARECORD WRITES THE NEXT RECORD OF A PREVIOUSLY 
 % OPENED FILE. NR IS SET TO NEXT RECORD TO WRITE  
'WRITEARECORD : 21 FCB FDOSENTRY DUP NEZ IF 0ERROR MSG DUP 255  
EQ IF 7ERROR ERR THEN 1 EQ IF 5ERROR ERR ELSE 6ERROR
ERR THEN THEN DROP ;

 % 0/1  MAKEAFILE MAKES A NEW FILE AND LEAVES THE  
 % BYTE ADDRESS OF THE FCB IN THE DIRECTORY AT TOP  
'MAKEAFILE : 22 FCB FDOSENTRY DUP 255 EQ IF 0ERROR MSG 7ERROR 
ERR THEN ;

 % 0/0  RENAMEFILE CHANGES THE NAME OF THE FCB (FCB&FCB+16) 
'RENAMEFILE : 23 FCB FDOSENTRY DROP ;

 % 0/0  ?LOGIN ANNOUNCES WHICH DRIVES ARE 'ON LINE'
'?LOGIN : 24 0 FDOSENTRY 4 0 DO 2 U/MOD 'DRIVE MSG SPACE 65
I + TYO SPACE EQZ IF 'NOT MSG THEN SPACE "ON LINE" MSG CR LOOP ;

 % 1/0  SETDMA SETS ADDRESS OF 128 BYTE I/O BUFFER (1/0) 
'SETDMA : 26 SWAP FDOSENTRY DROP ;

 % 0/1  ?ALLOCATION RETURNS ALLOCATION VECTOR AT TOP 
 % INCLUDED MERELY FOR COMPLETENESS  
'?ALLOCATION : 27 0 FDOSENTRY ;

 % 0/0  SETDRIVE SETS THE DRIVE TO READ-ONLY. TO RESET USE RESET
'SETDRIVE : 28 0 FDOSENTRY DROP ;

 % 0/1  RO-VECTOR RETURNS A BYTE MAP OF THE READ ONLY DRIVES
'RO-VECTOR : 29 0 FDOSENTRY ;

 % 1/0 SETDIRDMA SETS THE DIRECTORY I/O DMA TO THE ADDRESS AT TOP
 % WHEN YOU HAVE SEVERAL I/O BUFFERS IN STOIC DIRE CONSEQUENCES
 % FOLLOW IF THIS IS NOT USED! (ALL AUTOMATIC IN THIS SYSTEM)
'SETDIRDMA : 30 SWAP FDOSENTRY DROP ;

 %         ****** PRIMITIVE SEQUENTIAL FILE OPERATIONS ******


 % READFBUFF IS A SUBROUTINE FOR READING A RECORD INTO 
 % THE BUFFER OF THE CURRENT FILE
     ASSEMBLER< DEFINITIONS
   .
B PUSH, D PUSH, H PUSH, FCBAD LHLD, 36 D LXI, D DAD, 0 M MVI,
 H INX, 1 M MVI,  H INX, M E MOV, 0 D MVI, 14 C MVI, H PUSH,
BDOS CALL, H POP, H INX, H INX, XCHG, 26 C MVI, BDOS CALL,
 FCBAD LHLD, XCHG, 20 C MVI, BDOS CALL, A ANA, IFNZ, FCBAD LHLD,
32 D LXI, D DAD, M D MOV, D DCX, 7 B LXI, B DAD, D M MOV, 30 C MVI,
DMA D LXI, BDOS CALL, H POP, D POP, B POP, RET, THEN, 
0ERROR H LXI, (MSG) CALL, 1 CPI, IFZ, 4ERROR H LXI, ERROR JMP,
THEN, 3ERROR H LXI, ERROR JMP,

'READFBUFF CONSTANT

 % WRITEFBUFF IS A SUBROUTINE FOR WRITING A RECORD FROM
 % THE BUFFER OF THE CURRENT FILE
 
. B PUSH, D PUSH, H PUSH, FCBAD LHLD, 36 D LXI, D DAD, 0 M MVI,
 H INX, H INX, M E MOV, 0 D MVI, 14 C MVI, H PUSH, BDOS CALL,
 H POP, H INX, H INX, XCHG, 26 C MVI, BDOS CALL, FCBAD LHLD,
 XCHG, 21 C MVI, BDOS CALL, A ANA, IFNZ, FCBAD LHLD, 32 D LXI,
 D DAD, M D MOV, D DCX, 7 B LXI, B DAD, D M MOV, 30 C MVI, DMA D LXI,  
BDOS CALL, H POP, D POP, B POP, RET, THEN,
0ERROR H LXI, (MSG) CALL, 1 CPI, IFZ, 2 CPI, IFZ, 7ERROR H LXI,
ERROR JMP, THEN, 6ERROR H LXI, ERROR JMP, THEN, 5ERROR H LXI,
ERROR JMP,
  'WRITEFBUFF CONSTANT

 % (GETBYTE) GETS THE NEXT BYTE OF A FILE THAT HAS BEEN 
 % OPENED FOR READING INTO THE A REGISTER . 
 
  . "FILE IS WRITE-ONLY" S, . <L H LXI, ERROR JMP,
   .
FCBAD LHLD, H A MOV, L ORA, IFZ, 34 D LXI, D DAD, M A MOV,
 A ANA, L> JNZ, H INX, M A MOV, A ANA, IFZ, H INX, M A MOV,
 128 SBI, READFBUFF CZ, H INX, M A MOV, A ANA, READFBUFF CZ,
H DCX, M C MOV, M INR, 0 B MVI, 4 D LXI, B DAD, D DAD,
 M A MOV, RET,
THEN, THEN, 2ERROR H LXI, ERROR JMP,

'(GETBYTE) CONSTANT

 % (PUTBYTE) PUTS THE CONTENTS OF THE A REGISTER INTO
 % THE NEXT BYTE OF THE PREVIOUSLY OPENED FILE

. "FILE IS READ-ONLY" S, . <L H LXI, ERROR JMP,

 .
A C MOV, FCBAD LHLD, H A MOV, L ORA, IFZ, 34 D LXI,
D DAD, M A MOV, A ANA, L> JZ, H INX, M A MOV, A ANA,
IFZ, H INX, M A MOV, 128 SBI, WRITEFBUFF CZ, M E MOV,
 M INR, 0 D MVI, D DAD, 4 D LXI, D DAD, C M MOV, RET,
 THEN, THEN, 2ERROR H LXI,
ERROR JMP,
  '(PUTBYTE) CONSTANT
    > DEFINITIONS

 % 0/1  GETBYTE RETURNS THE NEXT BYTE FROM THE FILE ,USING
 % THE CURRENT FILE CONTROL BLOCK
'GETBYTE CODE< (GETBYTE) CALL, A L MOV, 0 H MVI, PUSH JMP, >

 % 1/0  PUTBYTE STORES THE BYTE AT TOP IN THE NEXT BYTE OF
 % THE FILE,USING THE CURRENT FILE CONTROL BLOCK
'PUTBYTE CODE< H POP, L A MOV, (PUTBYTE) CALL, NEXT JMP, >

 % 0/0  RECORDWRITE WRITES OUT THE CONTENTS OF THE CURRENT FILE
 % BUFFER INTO THE NEXT DISK RECORD
'RECORDWRITE CODE< WRITEFBUFF CALL, NEXT JMP, >

 % 0/0 RECORDREAD READS THE NEXT RECORD INTO THE CURRENT FILE BUFFER
'RECORDREAD CODE< READFBUFF CALL, NEXT JMP, >
 
 %  2/0  GETBYTES TAKES A BYTE COUNT AT TOP AND A BUFFER ADDRESS AT
 % TOP -1 AND READS THE SPECIFIED NUMBER OF BYTES FROM THE FHLE
 % SPECIFIED(BY THE CURRNT FCB INTO THE SAID BUFFER
'GETBYTES CODE< H POP, D POP, H A MOV, A ORA, NEXT JM, L ORA,
NEXT JZ, . D PUSH, H PUSH, (GETBYTE) CALL, H POP, D POP,
D STAX, D INX, H DCX, H A MOV, L ORA, JNZ, NEXT JMP, >

 % 2/0  PUTBYTES TAKES A BYTE COUNT AT TOP AND A BUFFER ADDRESS AT
 % TOP -1 AND WRITES THE SPECIFIED NUMBER OF BYTES TO THE DISK FILE
 % SPECIFIED BY THE CURRENT FCB FROM THE SAID BUFFER
'PUTBYTES CODE< H POP, D POP, H A MOV, A ORA, NEXT JM, L ORA,
NEXT JZ, . D PUSH, H PUSH, D LDAX, (PUTBYTE) CALL, H POP,
D POP, D INX, H DCX, H A MOV, L ORA, JNZ, NEXT JMP, >

 % 1/1  GETBLOCK GETS A BLOCK WHOSE STARTING ADDRESS IS AT
 % TOP FROM THE CURRENT FILE THAT HAS BEEN PREVIOUSLY OPENED
 % PUSHES -1 IF END OF FILE REACHED, OTHERWISE 0
'GETBLOCK CODE< FCBAD LHLD, 33 D LXI, D DAD, M A MOV, A ANA,
-1PUSH JNZ, T1 SHLD, 1024 H LXI, D POP, . <L D PUSH, H PUSH,
 (GETBYTE) CALL, H POP, D POP, D STAX, EOF CPI, IFZ, 
 D INX, H DCX, H A MOV, L ORA, L> JNZ, 0PUSH JMP, THEN,
 T1 LHLD, -1 M MVI, -1PUSH JMP, >

 % 1/1  PUTBLOCK  PUTS A BLOCK WHO'SE STARTING ADDRESS IS AT
 % TOP INTO THE CURRENT FILE THAT'S BEEN PREVIOUSLY WOPENED
 % PUSHES -1 IF END OF FILE REACHED, OTHERWISE 0
'PUTBLOCK CODE< FCBAD LHLD, 33 D LXI, D DAD, M A MOV, A ANA,
-1PUSH JNZ, T1 SHLD, 1024 H LXI, D POP, . <L D PUSH, H PUSH,
 D LDAX, PSW PUSH, (PUTBYTE) CALL, PSW POP, H POP, D POP,
  EOF CPI, IFZ,  D INX, H DCX, H A MOV, L ORA, L> JNZ, 0PUSH JMP,
 THEN, T1 LHLD, -1 M MVI, -1PUSH JMP, >

 % PRINTLINE PUTS UP ON THE CONSOLE THE NEXT LINE OF THE FILE
 % IN THE CURRENT FCB
 % PUSHES -1 IF END OF FILE REACHED, OTHERWISE 0.
 % STOPS TYPING IF KEY IS PRESSED, CONTINUES IF KEY PRESSED
'PRINTLINE CODE< FCBAD LHLD, 33 D LXI, D DAD, M A MOV,
A ANA, -1PUSH JNZ, H PUSH, . <L (GETBYTE) CALL, EOF CPI, IFZ,
PSW PUSH, (CLO) CALL, PSW POP, 10 CPI, L> JNZ, H POP,
 0PUSH JMP, THEN, H POP, -1 M MVI, -1PUSH JMP, >


 %              ****** BASIC DISC UTILITIES ******


 % 0/1 THERE? PUSHES -1 IF FILE IS ON LOGGED DISK, OTHERWISE PUSHES
 % 0 AND ANNOUNCES THE FACT
'THERE? : SEARCHFILE DUP EQZ IF 0ERROR MSG TYPEFCB 1ERROR MSG
?DRIVE ELSE UNDER THEN ;
 
 % 0/1 NOT-THERE? PUSHES 0 IF THE FILE IN THE FCB ALREADY EXISTS, AND
 % ANNOUNCES THE FACT; OTHERWISE PUSHES -1 
'NOT-THERE? : SEARCHFILE IF DROP 8ERROR MSG ?DRIVE CR BEGIN SEARCHAGAIN 
IF DROP "THERE'S ANOTHER" MSG TYPEFCB " ON" MSG ?DRIVE CR REPEAT 0  
ELSE -1 THEN ;
 
 % 1/0  EXIST SEARCHES FOR NAME ON TOP GIVES ERROR MESSAGE
 % IF THE FILE IS NOT FOUND 
'EXIST : AFILE INFCB THERE? EQZ IF ABORT THEN ;
 
 % 1/0  NOT-EXIST SEARCHES FOR NAME ON TOP, GIVES ERROR MESSAGE
 % IF THE FILE IS FOUND 
'NOT-EXIST : AFILE INFCB NOT-THERE? EQZ IF ABORT THEN ;

 % 0/0  SETUP SETS THE CURRENT DRIVE
'SETUP :  DRIVE# @ LOGIN ;

 % 1/0  DRIVE SETS THE CURRENT DRIVE 
'DRIVE : 0 MAX 3 MIN DUP LOGIN DRIVE# ! ;

 % NOW WE CAN HAVE PSEUDO CP/M DRIVE ACTIVE COMMANDS
'A: : 0 DRIVE ; 'B: : 1 DRIVE ; 'C: : 2 DRIVE ; 'D: : 3 DRIVE ;
 % WARNING! DRIVE SELECT WORDS NOT CHECKED OR DEBUGGED (I'VE ONLY
 % GOT ONE DRIVE)

 % 1/0  OPEN  OPENS THE FILE WHO'SE NAME IS AT TOP USING THE 
 % CURRENT FCB. THE FILE IS OPENED FOR READING ONLY
'OPEN : SETUP  INFCB OPENFILE -1 O/C B! 0 W/R B! DROP ;

 % 0/0  WOPEN   OPENS A FILE FOR WRITING.  FILE NAME ON TOP
 % OF THE STACK. ANY PREVIOUS VERSION OF THE FILE IS DELETED
 % THE FILE IS OPENED USING THE CURRENT FCB .SEVERAL FILES
 % CAN BE OPEN AT ANY TIME
'WOPEN : SETUP INFCB SEARCHFILE IF DROP DELETEFILE THEN MAKEAFILE
DROP OPENFILE DROP -1 O/C B! -1 W/R B! ;

 % 0/0  CLOSE   CLOSES THE FILE IN THE CURRENT FCB
'CLOSE : W/R B@ IF RB B@ GTZ IF RECORDWRITE THEN THEN  
DMA SETDIRDMA CLOSEFILE DROP 0 O/C B! ;

 % PUTNAMEINFCB TAKES WILDCARD OR AMBIGUOUS NAME AT TOP
 % AND PUTS THE NEXT OCCURENCE OF THE FILENAME IN THE FCB.
 % RETURNS -1 AT TOP IF SUCCESSFUL, OTHERWISE 0. FOR THIS
 % COMMAND TO WORK PROPERLY, SFLAG MUST INITIALLY BE SET
 % TO 0 ; THIS SHOULD BE AUTOMATIC!
'PUTNAMEINFCB : INFCB SFLAG @ IF SEARCHAGAIN ELSE SEARCHFILE
SFLAG -1<- THEN IF 4 MOD 32 * 1 + DMA + FNAD 11 MVBYTES -1
ELSE SFLAG 0<- 0 THEN ;

 % 1/0  DELETE  ERASES THE FILE WHOSE NAME IS AT THE TOP
 % OF THE STACK
'DELETE : AFILE EXIST DELETEFILE CLEARFCB ;

 % LIST-DIRECTORY LISTS ALL THE FILES ON THE DISK IN TWO COLUMNS
 % IN THE ORDER THAT THEY OCCUR IN THE DIRECTORY. IF YOU ONLY
 % WANT THE .STC FILES THEN TAKE OFF THE .??? AMBIGUOUS FT
'LIST-DIRECTORY : RESET SETUP AFILE SFLAG 0<- IFCR " FILES ON"
 MSG ?DRIVE CR CR 0 BEGIN '????????.??? PUTNAMEINFCB IF 1+ DUP
 <#> 2 OVER - SPACES TYPE ASCII / TYO SPACE TYPEFCB COLUMN 
B@ 30 GT IF CR ELSE 30 TAB THEN REPEAT DROP ;


 %               *********** DISK UTILITIES ********** 

 % 1/0  WPRINT TYPES A FILE ON THE CONSOLE (ACCEPTS AMBIGUOUS FILENAMES)
 % SYNTAX   'FILENAME WPRINT  OR  '????????.ASM WPRINT
 % DO NOT USE THIS IF YOU HAVE A FILE OPEN!
'WPRINT : RESET SETUP AFILE SFLAG 0<- BEGIN DUP PUTNAMEINFCB IF OPENFILE DROP
-1 O/C B! 0 W/R B! BEGIN PRINTLINE END CLOSE REPEAT DROP ;

 % 1/0  PRINT PRINTS THE FILE WHOSE NAME IS ADDRESSED AT TOP. THIS IS THE
 % ORIGINAL VERSION OF THE COMMAND
'PRINT : AFILE OPEN BEGIN GETBYTE DUP EOF NE IF TYO REPEAT DROP CLOSE ;

 % 2/0  'ORIGINAL 'COPY COPY  COPIES THE FILE WHOSE NAME IS AT TOP - 1 
 % TO A FILE WHOSE NAME IS AT TOP, AND DELETES ANY PREVIOUS VERSION OF 
 % THE FILE AT TOP
 % THIS COMMAND IS WRITTEN FOR A SINGLE DRIVE SYSTEM SO IT COULD PROBABLY
 % BE SIMPLIFIED FOR ALL YOU MORE FORTUNATE HACKERS WITH TWIN DRIVES
'COPY : SETUP OFILE WOPEN IFILE OPEN BEGIN IFILE BLOCKBASE
GETBLOCK DROP BLOCKBASE 1024 + GETBLOCK DROP OFILE BLOCKBASE
PUTBLOCK DROP BLOCKBASE 1024 + PUTBLOCK END IFILE CLOSE
OFILE CLOSE ;

 % 2/0  'OLDNAME 'NEWNAME RENAME  RENAMES THE FILE WHOSE
 % NAME IS AT TOP - 1 TO THE NAME AT TOP
'RENAME : AFILE DDUP NOT-EXIST EXIST
FCB 17 8224 FILL PUTINNAME FNAD DUP 16 + 11 MVBYTES
FCB 6 8224 FILL PUTINNAME 0 FCB B! 0 FCB 16 + B! RENAMEFILE ;

" ************************************************ " MSG CR
" ***  CP/M FILING SYSTEM HAS BEEN LOADED NOW  *** " MSG CR 
" ************************************************ " MSG CR
RADIX !

;F

