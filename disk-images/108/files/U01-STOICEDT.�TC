

% ***************************************************************************
% ** COPYRIGHT (C) MASSACHUSETTS INSTITUTE OF TECHNOLOGY AND HARVARD       **
% ** UNIVERSITY, BIOMEDICAL ENGINEERING CENTER 1977.  ALL RIGHTS RESERVED. **
% ***************************************************************************

% 8080 DISPLAY EDITOR
% J. SACHS 2/9/77
% MODIFIED TO RUN WITH STOICCPM.STC 
% BY A.R.M.CLARKE
% THE DOCUMENTATION IS AS THE ORIGINAL,EXCEPT FOR EXTRA 
% COMMANDS 'GRLIB, GWLIB, ISP, ICR, AND DCR.' ALL THESE
% ARE EXPLAINED IN THE PROGRAMME
% THE <A> COMMAND IS ERASED,THE PAGE HAS BEEN GIVEN AN
% ARBITRARY VALUE, AND I HAVE PUT IN CONTROL CHARACTERS
% AND UNIQUE CHARACTERS FOR THE CURSORS: SIMPLY RESTORE
% THE ORIGINAL 'DISPLAY-CURSORS' COMMAND.

RADIX @ OCTAL

% DEFINE EDITOR BRANCH
'EDITOR< BRANCH
EDITOR< DEFINITIONS

% EDITOR VARIABLES
0 'LAST VARIABLE		% PTR TO END OF TEXT BUFFER
				% (ALSO START OF X BUFFER)
0 'XLAST VARIABLE		% PTR TO END OF X BUFFER
0 'CP VARIABLE			% CURSOR
0 'P1 VARIABLE			% PTR TO START OF CURRENT STRING
0 'P2 VARIABLE			% PTR TO END OF CURRENT STRING
0 'P3 VARIABLE			% TEMPORARY
0 'C1 VARIABLE			% TEMPORARY
0 'IFLAG VARIABLE		% INPUT FILE ACTIVE FLAG
0 'OFLAG VARIABLE		% OUTPUT FILE ACTIVE FLAG
7 'INAME ARRAY			% INPUT FILE NAME
7 'ONAME ARRAY			% OUTPUT FILE NAME
33 'ESC VARIABLE		% ESCAPE CHAR FOR I/ COMMAND

400 'MARGIN CONSTANT		% DICTIONARY MARGIN FOR EDITOR MACROS, ETC.
'LIMIT : . MARGIN + ;		% LOWER MEMORY LIMIT

% MOVE CP N LINES
'L CODE<  B POP,  B A MOV,  A ORA,  IFM,  C ORA,  IFZ,
  .  .  CP LHLD,  XCHG,  LAST LHLD,
  -HL CALL,  D DAD,  H A MOV,  L ORA,  NEXT JZ,  XCHG,
  M A MOV,  H INX,  CP SHLD,  12 CPI,  JNZ,  B DCX,
  B A MOV,  C ORA,  JNZ,  NEXT JMP,
  THEN,  THEN,  B DCX,
  .  .  CP LHLD,  XCHG,  MEMORY LHLD,
  -HL CALL,  D DAD,  H A MOV,  L ORA,  NEXT JZ,  XCHG,
  H DCX,  M A MOV,  CP SHLD,  12 CPI,  JNZ,  B INX,
  B A MOV,  C ORA,  JNZ,  CP LHLD,  H INX,  CP SHLD,
  NEXT JMP,  >

% COMPARE TWO ARG STRINGS; BYTE COUNT AT TOP
'CMPBYTES CODE<  B POP,  D POP,  H POP,  B A MOV,  A ORA,
  0PUSH JM,  C ORA,  0PUSH JZ,  .  D LDAX,  M CMP,
  0PUSH JNZ,  D INX,  H INX,  B DCX,  B A MOV,  C ORA,
  JNZ,  -1PUSH JMP,  >

% APPEND AN INPUT LINE TO TEXT BUFFER
. <L "CORE FULL" S,

'GETLINE CODE<
  FCBAD LHLD, 41 D LXI, D DAD, M A MOV, 
  H POP,   A ANA, -1PUSH JNZ,
    T1 SHLD,
  .  <L
  .  <L
  CP LHLD,  XCHG,  P2 LHLD,  -HL CALL,  D DAD,  IFC,
  (GETBYTE) CALL,
  EOF CPI,  -1PUSH JZ,
  CP LHLD,  A M MOV,  H INX,  CP SHLD,
  15   CPI, IFZ,
  L> JMP,
  THEN,  T1 LHLD,  H DCX,  T1 SHLD,
  H A MOV,  L ORA,  L> JNZ,  0PUSH JMP,
  THEN,  L> H LXI,  ERROR JMP,  >

% DISPLAY CURSORS
'DISPLAY-CURSORS CODE<  D POP,  -DE CALL,
  P1 LHLD,  D DAD,  H A MOV,  L ORA,  IFNZ,
  25 A MVI,  D PUSH,  (TTO) CALL,  D POP,  THEN,
  CP LHLD,  D DAD,  H A MOV,  L ORA,  IFNZ,
D PUSH, 03 A MVI, (TTO) CALL, 120 A MVI, (TTO) CALL, D POP, THEN,
  P2 LHLD,  D DAD,  H A MOV,  L ORA,  IFNZ,
  21 A MVI,  (TTO) CALL,  THEN,  NEXT JMP, >

% DISPLAY A CHARACTER
'DISPLAY-CHAR CODE<  H POP,  L A MOV,  12 CPI,  IFZ,  
 40 CPI, IFP, 15 CPI,
  IFZ,  11 CPI,  IFZ,  PSW PUSH,  136 A MVI,  (TTO) CALL,
  PSW POP,  100 ADI,  THEN,  THEN,  THEN,  (TTO) CALL, THEN,  NEXT JMP, >

% EXCHANGE P1 AND P2 UNLESS P1<P2
'P1<P2 : P1 @ P2 @ UGT IF P1 P2 XCHG THEN ;

% SET P1 TO CP
'S1 : CP P1 MOVE ;

% SET P2 TO CP
'S2 : CP P2 MOVE ;

% SET CP TO BEGINNING OF TEXT BUFFER
'B : MEMORY CP MOVE ;

% SET CP TO END OF TEXT BUFFER
'Z : LAST  CP MOVE ;

% MOVE CP N CHARACTERS
'M : CP @ + LAST @ MIN MEMORY @ MAX CP ! ;

% SET P1, MOVE N CHARACTERS, SET P2
'<M> : S1 M S2 P1<P2 ;

% SET P1, MOVE N LINES, SET P2
'<L> : S1 L S2 P1<P2 ;

% SET P1 TO FIRST, SET P2 TO LAST
'<ALL> : B S1 Z S2 ;

% PUSH THE LINE NUMBER OF THE LINE CONTAINING THE CURSOR
'LINE# : 0 CP @ MEMORY @ DO I B@ 15 EQ + LOOP MINUS ;

% STRING SEARCH
'<S> : C1 ! P3 ! IF
   0 LAST @ C1 @ - CP @ UDO I P3 @ C1 @ CMPBYTES IF -1
   UNDER I P1 ! I C1 @ + DUP P2 ! CP ! EXIT THEN ULOOP
  ELSE
   0 CP @ MEMORY @ UDO I' P3 @ C1 @ CMPBYTES IF -1
   UNDER I' DUP P1 ! CP ! I' C1 @ + P2 ! EXIT THEN ULOOP
  THEN ;

'<SS> : SWAP COUNT <S> NOT IF 'MISSING ERR THEN ;
'S : -1 <SS> ;
'BS : 0 <SS> ;

% DELETE BETWEEN P1 AND P2
'<D> : P1 @ 1- P2 @ 1- P1 @ MEMORY @ - RMVBYTES
   MEMORY @ P1 @ - P2 @ + MEMORY ! P2 P1 MOVE P2 CP MOVE ;

% DELETE N CHARACTERS
'D : <M> <D> ;

% DELETE N LINES
'DL : <L> <D> ;

% DELETE TEXT BUFFER
'DA : <ALL> <D> ;

% INSERT STRING
'<I> : C1 ! P3 ! MEMORY @ C1 @ - LIMIT ULE IF "CORE FULL"
  ERR THEN MEMORY @ DUP C1 @ - CP @ MEMORY @ - MVBYTES
  MEMORY @ C1 @ - MEMORY ! P3 @ CP @ C1 @ - C1 @ MVBYTES
  S2 CP @ C1 @ - P1 ! ;

% INSERT STRING FOLLOWED BY CR
'<IL> : 2 + <I> 12 15 P2 @ DUP 2SWAP 2 - B! 1- B! ;

% INSERT STRING FOLLOWED BY FF
'<IP> : 1+ <I> 14 P2 @ 1- B! ;

'IS : COUNT <I> ;
'IL : COUNT <IL> ;
'IP : COUNT <IP> ;

% INSERT CR
'ICR : '&15&&12& IS ;

% INSERT A SPACE
'ISP : '&40& IS ;

% INSERT FF
'IFF : '&14& IS ;

% INSERT NUMBER AS TEXT
'I# : <#> <I> ;

% REPLACE CURRENT STRING
'U : <D> IS ;

% STRING SUBSTITUTE
'C : SWAP S U ;
'BC : SWAP BS U P1 CP MOVE ;

% SEARCH AND DESTROY
'SD : S <D> ;
'BSD : BS <D> ;

% DELETE THE NEXT RETURN 
'DCR : '&15&&12& SD ;

% ADD AN OFFSET TO ALL TEXT BUFFER POINTERS
'ADJUST : DUP MEMORY +! DUP LAST +! DUP CP +! DUP P1 +! P2 +! ;

% DELETE X BUFFER
'XD : XLAST @ LAST @ -
  LAST @ 1- XLAST @ 1- LAST @ MEMORY @ - RMVBYTES
  ADJUST ;

% COPY TEXT BETWEEN P1 AND P2 INTO X BUFFER
'<XC> : XD
  MEMORY @ P2 @ P1 @ - - LIMIT ULE IF "CORE FULL" ERR THEN
  MEMORY @ DUP P2 @ P1 @ - - LAST @ MEMORY @ - MVBYTES
  P1 @ P2 @ - ADJUST P1 @ LAST @ P2 @ P1 @ - MVBYTES ;

% COPY N CHARACTERS INTO "X" BUFFER
'XC : <M> <XC> ;

% COPY N LINES INTO "X" BUFFER
'XCL : <L> <XC> ;

% MOVE N CHARACTERS INTO "X" BUFFER
'XM : XC <D> ;

% MOVE N LINES INTO "X" BUFFER
'XML : XCL <D> ;

% INSERT CONTENTS OF "X" BUFFER AT CP
'XG : LAST @ XLAST @ OVER - <I> ;

% OUTPUT TEXT TO OUTPUT FILE
'<P> : OFLAG @ IF OFILE P1 @ P2 @ OVER - PUTBYTES ELSE
  "NO OUTPUT FILE" ERR THEN ;
'PEOF :  OFILE EOF PUTBYTE ;
'P : <M> <P> ;
'PL : <L> <P> ;
'PA : <ALL> <P> ;

% MOVE TEXT BUFFER DOWN
'DOWN : MEMORY @ LIMIT CP @ MEMORY @ - MVBYTES
  S2 CP @ MEMORY @ LIMIT - - CP ! S1 LIMIT MEMORY ! ;

% MOVE TEXT BUFFER UP
'UP : CP @ 1- P2 @ 1- CP @ LIMIT - RMVBYTES
  MEMORY @ P2 @ CP @ - + MEMORY !
  P2 @ CP @ P1 @ - - P1 ! P1 CP MOVE ;

% APPEND TEXT FROM INPUT FILE
'<AL> : IFLAG @ IF Z DOWN IFILE GETLINE UP ELSE 
"NO INPUT FILE" ERR THEN DUP IF -1 EF B! THEN ;
'<AP> : ( 64 <AL> ) ;

'AL : <AL> IF "EOF" ERR THEN ;
'AP : <AP> IF "EOF" ERR THEN ;

% DELETE TEXT-BUFFER AND APPEND FROM INPUT FILE
'<YL> : DA <AL> ;
'<YP> : DA <AP> ;
'YL : DA AL ;
'YP : DA AP ;

% WRITE A PAGE AND READ NEXT PAGE
'<R> : ( PA 1 <YP> ) ;
'R : ( PA 1 YP ) ;

% GLOBAL SEARCH AND REPLACE COMMANDS
'<N> : BEGIN -1 OVER COUNT <S> IF DROP -1 -1 ELSE
  1 <R> IF DROP 0 -1 ELSE 0 THEN THEN END ;
'N : <N> NOT IF 'MISSING ERR THEN ;
'V : SWAP N U ;

% CLOSE INPUT AND OUTPUT FILES
'IOCLOSE : IFLAG @ IF IFLAG 0<- IFILE CLOSE THEN 
           OFLAG @ IF OFLAG 0<- OFILE CLOSE THEN ;

% GET INPUT FILE
'GR : DUP INAME OVER B@ 1+ MVBYTES IFILE OPEN IFLAG -1<- ;

% GET OUTPUT FILE
'GW : DUP ONAME OVER B@ 1+ MVBYTES OFILE WOPEN OFLAG -1<- ;

% GET INPUT LIBRARY FILE AND INSERT AT CURRENT CURSOR POSITION
'GRLIB : AFILE OPEN DOWN BEGIN 1 GETLINE END UP CLOSE ;

% PUTS THE TEXT BETWEEN P1 AND P2 INTO THE NAMED NEW LIBRARY FILE
'GWLIB : AFILE WOPEN P1 @ P2 @ OVER - 
  PUTBYTES EOF PUTBYTE CLOSE ;

% FLUSH TEXT BUFFER AND INPUT AND OUTPUT FILES
'GX : DA OFLAG @ IF IOCLOSE ONAME DELETE ELSE IOCLOSE THEN ;

% OPEN INPUT FILE, CREATE SCRATCH FILE, READ 1ST PAGE OF INPUT FILE
'O : GR '++ED++ GW 1 YP B ;

% WRITE OUT AND CLOSE FILES
'W : IFLAG @ IF BEGIN 1 <R> END PA PEOF IOCLOSE
  INAME DELETE ONAME INAME RENAME DA ELSE
  PA PEOF DA IOCLOSE THEN ;

% WRITE AND RENAME
'WR : IFLAG @ IF BEGIN 1 <R> END THEN PA PEOF
   DA IOCLOSE ONAME SWAP RENAME ;

% WRITE AND RE-OPEN COMMANDS
'WO : W INAME O ;
'WRO : DUP WR O ;

% TEXT TYPE-OUT COMMANDS
'<T> : P1 @ P2 @ OVER - TYPE ;
'T : <M> <T> ;
'TL : <L> <T> ;
'TA : <ALL> <T> ;

% ERASE SCREEN
'ERASE : 32 TYO ;

% DISPLAY DIRECTORY, WAIT FOR CR
'FL : ERASE LIST-DIRECTORY BEGIN TYI 15 EQ END ;

% DISPLAY TEXT BUFFER
'DISPLAY : ERASE SPACE SPACE
  IFLAG @ IF INAME COUNT 14 MIN TYPE ELSE 52 TYO THEN
  54 TYO
  OFLAG @ IF ONAME
COUNT 14 MIN TYPE ELSE 52 TYO THEN
  CR CR
  CP @ <L -10 L 20 L CP @ DUP -22 L CP @
  L> CP ! UDO I DISPLAY-CURSORS I B@ DISPLAY-CHAR ULOOP
  DISPLAY-CURSORS ;

% EDITOR PROMPT MESSAGE
'EDIT-PROMPT :
  CHECK B@ 60 EQ IF DISPLAY 21 TYO CR CR THEN
  PROMPT0 ;

% EDITOR ERROR HANDLER
'ERRS : ERASE () <TTO> OUT ! () <TTI> IN ! MSG CR . MSG
  BEGIN TYI 15 EQ END
  ABORT ;

% EXIT EDITOR, FLUSH TEXT AND X BUFFERS
'H : GX ERASE () PROMPT0 PROMPT ! () ERRMSG0 ERRMSG ! >
  XLAST MEMORY MOVE ;

% INSERT MODE
'I/DISPLAY : CP @ LAST @ OVER LAST ! DISPLAY LAST ! CP ! ;

'I/ : DOWN I/DISPLAY BEGIN
   CP @ P2 @ EQ IF "CORE FULL" ERR THEN
   TYI DUP ESC @ EQ IF DROP -1 ELSE
       DUP 177 EQ IF
        DROP CP @ P1 @ NE IF CP 1-! I/DISPLAY THEN
        0 ELSE
       DUP EQZ IF DROP P1 CP MOVE I/DISPLAY 0 ELSE
       DUP DUP TYO BEGIN CP @ B! CP 1+!  
       15 EQ IF 12 DUP REPEAT 0 THEN THEN THEN
  END UP P2 CP MOVE
;

% CONDITIONAL CHANGE COMMANDS
'CU :
  DISPLAY "&15&TYPE A KEY" MSG TYI
  DUP 15 EQ IF
   DROP 0 ELSE
   12 EQ IF
    DUP U 0 ELSE
    2DROP -1 THEN
   THEN
;

'CC : BEGIN OVER S CU END ;
'BCC : BEGIN OVER BS CU P1 CP MOVE END ;
'CV : BEGIN OVER N CU END ;

> DEFINITIONS

EDITOR<
'EDIT : () EDIT-PROMPT PROMPT ! () ERRS ERRMSG ! EDITOR<
  MEMORY @ DUP LAST ! DUP XLAST ! DUP CP ! DUP P1 ! P2 ! ;
>

RADIX !
;F



***EOF***
