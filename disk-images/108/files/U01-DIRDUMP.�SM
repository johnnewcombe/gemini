








	; ***********************************************
	; *						*
	; *		DIRDUMP VERSION 1.0		*
	; *						*
	; ***********************************************


PAGE



	; THIS PROGRAM CAN BE USED TO PROVIDE A COMPLETE DIRECTORY
	; DUMP OF A CP/M VERSION 2 DISK. THE DIRECTORY ENTRIES ARE
	; GROUPED UNDER THEIR USER NUMBERS. 

	; THE ORIGINAL USER PARTITION IS RESTORED AFTER USE, AS IS
	; THE ORIGINAL DRIVE.

	; IF THE DRIVE CODE IS OMMITED, THE CURRENT DRIVE IS ASSUMED.


	; FORMAT OF COMMAND:

	; DIRDUMP [<DRIVE NAME>][*]<CR>

	; WHERE <DRIVE NAME> IS A SINGLE LETTER (A TO P) FOLLOWED BY
	; A COLON, <CR> IS A CARRIAGE RETURN, AND ITEMS ENCLOSED IN
	; SQUARE BRACKETS ARE OPTIONAL AND MAY APPEAR IN ANY ORDER.

	; IF THE DRIVE NAME  IS OMMITED, THE CURRENTLY LOGGED DRIVE IS
	; ASSUMED.

	; IF THE ASTERISK IS PRESENT, THE OUTPUT IS DIRECTED TO THE
	; SYSTEM LIST DEVICE, OTHERWISE THE OUTPUT IS DIRECTED TO THE
	; SYSTEM CONSOLE DEVICE. NOTE THAT THE PARAMETERS CAN BE SPACED
	; APART TO MAKE THEM MORE READABLE.

	; FOR INSTANCE
	; DIRDUMP * C:<CR>
	; WOULD DUMP DIRECTORY OF DRIVE C TO THE PRINTER



PAGE

	; EQUIVALANCE TABLE:
	; =========== ======


BDOS		EQU 5		; BDOS ENTRY POINT
CONOUT		EQU 2		; CONSOLE OUTPUT FUNCTION CODE
LIST		EQU 5		; LIST OUTPUT FUNCTION CODE
SEARCH$FIRST	EQU 17		; SEARCH FOR FIRST FUNCTION CODE
SEARCH$NEXT	EQU 18		; SEARCH FOR NEXT FUNCTION CODE
GET$VERS	EQU 12		; RETURN VERSION NUMBER FUNCTION CODE
GET$USR		EQ 32		; GET/SET USR NUMBER FUNCTION CODE
SET$USR		EQU GET$USR
OP$MESS		EQU 9		; PRINT MESSAGE CODE
SET$DMA		EQU 26		; SET DMA BUFFER ADDRESS

SPACE		EQU 20H		; ASCII SPACE CODE

COMND$TAIL	EQU 80H		; ADDRESS OF DEFAULT DMA BUFFER


PAGE

	; CODE SECTION
	; ==== =======

	ASEG

	ORG	100H		; SET TO START OF TPA


	LXI	H,0		; CLEAR HL
	DAD	SP		; GET SP VALUE

	SHLD	OLD$STK		; SAVE IT

	LXI	SP,NEW$STK	; INITIATE NEW STACK

	LXI	D,SIGNON	; POINT TO SIGN ON MESSAGE
	MVI	C,OP$MESS	; SET BDOS CALL CODE

	CALL	BDOS		; GIVE A MESSAGE


	; STAGE 1:-
	; MAKE SURE WE ARE UNDER VERSION 2.0 OR GREATER.

	MVI	C,GET$VERS	; FIND OUT VERSION
	CALL	BDOS		; BY A BDOS CALL

	MOV	A,H		; IF (HL)=0 THEN WE ARE UNDER 1.4 OR EARLIER
	ORA	L
	JNZ	START		; IF MP/M OR CP/M V2.0+ THEN CONTINUE

	LXI	D,BAD$VERS	; POINT TO MESSAGE
	MVI	C,OP$MESS	; SET O/P MESSAGE CODE
	CALL	BDOS		; AND GO DO IT.

BAD$EXIT:
	LHLD	OLD$STK		; RESTORE CCP STACK
	SPHL

	RET			; AND RETURN TO CCP

BAD$VERS:

	DB	0AH,0DH
	DB	'NEEDS MP/M OR CP/M V2.0+ TO OPERATE'
	DB	0AH,0DH,7,'$'


SIGNON:
	DB	0AH,0DH
	DB	'DIRDUMP VERSION 1.0'
	DB	0AH,0DH
	DB	'======= ======= ==='
	DB	0AH,0AH,0AH,0DH,'$'


START:
	; STAGE 2:-
	; FIND OUT WHICH USER PARTITION WE ARE CURRENTLY IN AND
	; SAVE THE RESULT

	MVI	C,GET$USR	; FIND USER CODE
	MVI	E,-1		; REQUIERS 0FFH IN REG E
	CALL	BDOS

	STA	OLD$USR		; SAVE IT

	; STAGE 3:-
	; TEST THE COMMAND TAIL WHICH CP/M HAS SET UP FOR US IN
	; THE DEFAULT DMA BUFFER AT 80H. IF THE TAIL IS VALID
	; THEN WE CONTINUE, ELSE WE PRINT A MESSAGE AND EXIT.

	LXI	H,COMND$TAIL	; POINT TO DMA BUFFER

	MOV	A,M		; SHOULD BE A COUNT
	ORA	A		; IF ZERO THEN USE DEFAULT DRIVE
	JZ	DEFLT
LOOP1:
	INX	H		; ELSE FIND DRIVE NAME
	MOV	A,M		; GET CHARATER
	CPI	0		; ZERO=END OF MESSAGE- USE DEFAULT DRIVE
	JZ	DEFLT
	CPI	SPACE		; IGNORE SPACES
	JZ	LOOP1

	; AT THIS POINT WE SHOULD HAVE EITHER A DRIVE NAME
	; OR AN ASTERISK IN REGISTER A. IF IT IS A DRIVE NAME
	; THEN WE MUST TEST THAT IT IS VALID.
	; AND IF IT IS NOT, THEN WE TERMINATE THE PROGRAM.

	CPI	'*'		; TEST IF PRINT MARKER
	JZ	OP$PRINT	; YES- LEAP AWAY

	; ITS A DRIVE NAME 

	SUI	'A'		; TEST IF LESS THAN 'A'
	JC	DERROR		; IF SO THEN TERMINATE

	CPI	'Q'-'A'		; TEST IF GREATER THAN 'P'
	JNC	DERROR		; TERMINATE IF SO.

	INR	A		; ADJUST TO BDOS EXPECTED VALUE
	STA	DRIVE		; SAVE IN F.C.B. DRIVE AREA

	INX	H		; POINT TO NEXT CHARACTER IN COMMAND TAIL.
	MOV	A,M		; IT SHOULD BE A COLON
	CPI	':'
	JNZ	DERROR		; IF NOT THEN ERROR
LOOPX:
	INX	H		; PROCESS THE REST OF THE COMMAND TAIL
	MOV	A,M
	ORA	A		; TEST FOR END OF COMMAND TAIL
	JZ	DEFLT		; GOOD. CONTINUE EXECUTION
	CPI	SPACE		; IS IT A SPACE?
	JZ	LOOPX		; YES- IGNORE IT

	CPI	'*'		; PRINT MARKER?
	JZ	OP$PRINT	; YES- PROCESS IT

DERROR:
	; IF WE GET TO THIS POINT, THERE WAS AN ERROR IN
	; THE COMMAND TAIL. THIS COULD BE AN INVALID
	; DRIVE NAME OR AN INVALID CHARACTER.

	LXI	D,BAD$TAIL	; POINT TO MESSAGE
	MVI	C,OP$MESS	; SET MESSAGE OUTPUT CODE
	CALL	BDOS		; DO IT.

	JMP	BAD$EXIT	; EXIT TO CCP

BAD$TAIL:
	DB	0AH,0DH
	DB	'INVALID COMMAND TAIL -- OPERATION ABORTED'
	DB	0AH,0DH,7,'$'


OP$PRINT:
	; THE PRINT COMMAND HAS BEEN RECOGNISED IN THE COMMAND TAIL.
	; WE NOW SET THE LOCATION 'PRINT$DEVICE' TO CONTAIN THE
	; BDOS CODE FOR LIST OUTPUT (SEE ROUTINE 'PRINT' FOR DETAILS)

	LDA	PRINT$DEVICE	; TEST IF ALREADY MARKED
	CPI	LIST		; WILL BE SET TO 'LIST' IF SO
	JZ	DERROR		; MARK COMMAND ERROR ALREADY SET TO 'LIST'

	MVI	A,LIST
	STA	PRINT$DEVICE	; SAVE IN RAM
	JMP	LOOP1		; PROCESS THE REST OF THE COMMAND TAIL



 
PAGE

DEFLT:

	; STAGE 4:-
	; THE COMMAND TAIL HAS NOW BEEN PROCESSED, ALL THAT
	; WE HAVE TO DO NOW, IS TO SEARCH THE DIRECTORY UNDER
	; EACH USER CODE AND SAVE THE RESULTS IN A BUFFER.

	; WHEN THE BUFFER IS  FULL, WE PRINT IT. WE DO THIS UNTIL
	; THERE ARE NO MORE MATCHES UNER USER 15. THEN WE PERFORM
	; A WARM BOOT TO CP/M

	LXI	D,DMA$BUFF	; POINT TO NEW DMA BUFFER
	MVI	C,SETDMA	; CALL CODE
	CALL	BDOS

	XRA	A		; START IN USER PARTITION 0
	DCR	A
	STA	USER$NO		; SAVE IT

LOOP2:
	LDA	USER$NO
	CPI	15		; TEST IF WE HAVE JUST PROCESSED USER 15
	JZ	GOOD$EXIT	; YES- EXIT

	INR	A		; MARK AND SELECT NEXT USER PARTITION
	STA	USER$NO		; MARK

	MOV	E,A		; CODE TO E
	MVI	C,SET$USR	; CALL FUNCTION TO C
	CALL	BDOS		; SET USER PARTITION

	LXI	H,USER$MESS	; POINT TO USER NUMBER MESSAGE
	XRA	A		; INDICATE TO ADDBUFF THAT (HL) POINTS TO MESS.
	CALL	ADDBUFF		; ADD MESSAGE TO PRINT BUFFER

	LXI	H,NUMBERS	; POINT TO USER NUMBER ASCII TABLE

	LDA	USER$NO		; GET USER NUMBER
	ORA	A		; CLEAR THE CARRY FLAG

	RAL			; *2
	RAL			; *4 (BECAUSE EACH ENTRY IS 4 CHARS LONG)

	ADD	L		; ADD IN TO TABLE BASE ADDRESS
	JNC	$+4
	INR	H
	MOV	L,A		; (HL) POINTS TO USER NUMBER IN ASCII

	XRA	A		; MARK MESSAGE TO ADDBUFF

	CALL	ADDBUFF		; AND ADD TO PRINT BUFFER

	LXI	H,CRETS		; PONT TO CARRIAGE RETURNS
	CALL	ADDBUFF		; (A) IS ALREADY 0

	; NOW WE SET UP AND POINT TO THE FCB AND SEARCH FOR ANY MATCH


	LXI	D,FCB		; POINT TO FCB
	MVI	C,SEARCH$FIRST	; SET FUNCTION CODE
	CALL	BDOS

	INR	A		; TEST IF A MATCH HAS OCCURED
	JZ	EMPTY$USR	; NO- THIS PARTITION IS EMPTY

	DCR	A		; COLLECT THE FILENAME FROM THE DMA BUFFER
	ORA	A		; CLEAR THE CARRY FLAG
LOOP5:
	RAL			; (A)=(A)*2
	RAL			; 	 *4
	RAL			; 	 *8
	RAL			; 	 *16
	RAL			;	 *32

	LXI	H,DMA$BUFF	; POINT TO DMA BUFFER

	ADD	L		; ADD IN POSITIONAL OFFSET
	JNC	$+4		; IF NO CARRY THEN DO NOT INCREMENT H
	INR	H
	MOV	L,A		; (HL) POINTS TO MATCHED ENTRY IN BUFFER

	XRA	A		; INDICATE (HL) = FILENAME POINTER TO ADDBUFF
	INR	A
	CALL	ADDBUFF		; AND ADD IT TO PRINT BUFFER

	LXI	D,FCB		; POINT TO FCB
	MVI	C,SEARCH$NEXT	; SET FUNCTION CODE
	CALL	BDOS

	INR	A		; TEST IF MATCH DECLARED
	JZ	LOOP2		; NO- CHANGE USER PARTITION

	DCR	A		; MATCH DECLARED - ADD TO PRINT BUFFER
	ORA	A		; CLEAR THE CARRY FLAG
	JMP	LOOP5


USER$MESS:

	DB	0AH,0DH
	DB	'         Directory for user partition $'

NUMBERS:
	DB	'0: $'
	DB	'1: $'
	DB	'2: $'
	DB	'3: $'
	DB	'4: $'
	DB	'5: $'
	DB	'6: $'
	DB	'7: $'
	DB	'8: $'
	DB	'9: $'
	DB	'10:$'
	DB	'11:$'
	DB	'12:$'
	DB	'13:$'
	DB	'14:$'
	DB	'15:$'

CRETS:
	DB	0DH,0AH,0AH,'$'



PAGE


EMPTY$USR:
	; USER PARTITION IS EMPTY, SO WE PUT A MESSAGE TO SAY THIS IN
	; THE PRINT BUFFER.

	LXI	H,EMPTY$MESS	; POINT TO MESSAGE
	XRA	A		; MARK AS MESSAGE
	CALL	ADDBUFF		; ADD TO PRINT BUFFER

	JMP	LOOP2		; AND PROCESS NEXT USER PARTITION


EMPTY$MESS:
	DB	'             <<< PARTITION EMPTY >>>'
	DB	0AH,0DH,'$'



GOOD$EXIT:
	; EXIT FROM HERE WHEN WE HAVE FINISHED THE DUMP

	LXI	H,ENDMESS	; POINT TO MESSAGE
	XRA	A		; MARK AS MESSAGE
	CALL	ADDBUFF		; ADD TO BUFFER

	CALL	PRINT		; EMPTY THE BUFFER

	LDA	OLD$USR		; RESTORE ORIGINAL PARTITION
	MOV	E,A
	MVI	C,SET$USR
	CALL	BDOS

	JMP	0		; AND WARM BOOT TO CP/M


ENDMESS:
	DB	0AH,0AH,0DH
	DB	'            <<< END OF DIRECTORY >>>'
	DB	0AH,0DH
	DB	'$'


PAGE

ADDBUFF:
	; THIS ROUTINE ADDS INFORMATION TO THE PRINT BUFFER.
	; IF THE BUFFER IS FULL, IT IS PRINTED AND EMPTIED BEFORE
	; RETURNING TO THE CALLING ROUTINE

	; ON ENTRY:

	; (HL) IS EITHER A POINTER TO A MESSAGE TERMINATED WITH A '$'
	; OR A POINTER TO A BDOS MATCHED DIRECTORY ENTRY.

	; (A) IS EITHER 0 OR NOT 0.
	; IF (A)=0 THEN (HL) IS A MESSAGE POINTER
	; IF (A)= NOT 0 THEN (HL) IS A DIRECTORY MATCH POINTER

	; ON EXIT:
	; NO PARAMETERS

	; REGISTERS AFFECTED:
	; NONE


	PUSH	H		; SAVE STATUS
	PUSH	D
	PUSH	B
	PUSH	PSW

	XCHG			; PUT POINTER INTO DE
	ORA	A		; TEST IF MESSAGE
	JZ	ADDMESS		; YES- GO DO IT

	; IF WE GET TO THIS POINT, WE HAVE A DIRECTORY MATCH AT (DE)

	LHLD	BUFF$PTR	; GET BUFFER POINTER

	LDA	COLUMN		; TEST IF COLUMN IS ZERO
	ORA	A
	JZ	ADD$DIR		; YES- DONT INSERT FNAME SEPERATOR

	MVI	C,3		; SET COUNT
	MVI	M,SPACE
	INX	H
	DCR	C
	JNZ	$-4		; SPACE FILL

	MVI	M,':'		; SEPERATOR
	INX	H

	MVI	C,3		; SET COUNT
	MVI	M,SPACE
	INX	H
	DCR	C
	JNZ	$-4		; SPACE FILL
ADD$DIR:
	INX	D		; POINT TO FILENAME
	MVI	C,8		; SET A COPY COUNT

LOOP6:
	LDAX	D		; GET BYTE
	MOV	M,A		; COPY TO BUFFER

	INX	H
	INX	D		; UP THE POINTERS
	DCR	C		; DOWN THE COUNT
	JNZ	LOOP6		; COPY ALL

	MVI	M,'.'		; DOT TO EXTENSION
	INX	H

	MVI	C,3		; SET COUNT
LOOP7:
	LDAX	D		; GET BYTE
	MOV	M,A		; SAVE IT

	INX	H		; UP POINTERS
	INX	D
	DCR	C		; DOWN COUNT

	JNZ	LOOP7		; COPY ALL


	LDA	COLUMN		; TEST IF CR/LF NEEDED.

	INR	A		; INCREMENT TO NEXT
	STA	COLUMN		; SAVE COLUMN NUMBER

	CPI	4		; PUT CR/LF AT END OF FOURTH COLUMN
	JNZ	ADD$EXIT	; EXIT IF NOT

	MVI	M,0DH		; SET CARRIAGE RETURN CODE
	INX	H
	MVI	M,0AH		; SET LINE FEED CODE

	XRA	A		; SET COLUMN ZERO
	STA	COLUMN

	INX	H		; MARK NEXT FREE BYTE OF PRINT BUFFER
	JMP	ADD$EXIT


ADD$EXIT:
	SHLD	BUFF$PTR	; AND SAVE BUFFER POINTER

	XCHG			; PUT POINTER TO DE
	LHLD	BDOS+1		; GET TOP OF MEMORY VALUE FROM BDOS JUMP

	LXI	B,(NOT 200)+1	; DO NOT ALLOW BUFFER TO OVER-RUN AVAILABLE RAM
	DAD	B

	; (HL)=MEMTOP - 200
	; (DE)=TOP OF PRINT BUFFER

	MOV	A,L		; SUBTRACT (DE) FROM (HL)
	SUB	E		; AND PUT RESULT INTO HL
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A		;  IF CARRY IS SET THEN WE MUST PRINT THE BUFF.

	CC	PRINT

	POP	PSW		; RESTORE STATUS
	POP	B
	POP	D
	POP	H
	RET			; RETURN TO CALLER


ADD$MESS:
	; (DE) IS A MESSAGE POINTER

	LHLD	BUFF$PTR	; GET BUFFER POINTER TO HL
LOOP8:
	LDAX	D		; GET BYTE OF MESSAGE
	CPI	'$'		; TEST FOR TERMINATOR
	JZ	ADM1		; YES- EXIT LOOP

	MOV	M,A		; SAVE THE CHARACTER
	INX	H
	INX	D		; UP THE POINTERS
	JMP	LOOP8		; COPY WHOLE MESSAGE

ADM1:
	XRA	A		; SET COLUMN 0
	STA	COLUMN
	JMP	ADD$EXIT	; EXIT


PAGE



PRINT:
	; THIS ROUTINE PRINTS OUT THE BUFFER AND RESETS THE BUFFER POINTER
	; TO START OF BUFFER

	; ON ENTRY:

	; END OF BUFFER STORED IN 'BUFF$PTR'
	; DESTINATION FOR OUTPUT GIVEN BY 'PRINT$DEVICE'
	; WHICH HOLDS THE BDOS CALL CODE FOR EITHER CONOUT
	; OR LIST


	; ON EXIT:

	; 'BUFF$PTR' SET TO START OF BUFFER

	; REGISTERS AFFECTED:
	; ALL


	LHLD	BUFF$PTR		; GET BUFFER POINTER
	LXI	D,BUFFER		; SUBTRACT BUFFER START FROM IT
	MOV	A,L			; & PUT RESULT INTO DE
	SUB	E
	MOV	E,A
	MOV	A,H
	SBB	D
	MOV	D,A

	LXI	H,BUFFER		; POINT BUFF$PTR TO START OF BUFF
	SHLD	BUFF$PTR

	; (DE) = COUNT
	; (HL) = BUFFER POINTER

LOOP9:
	MOV	A,D			; TEST IF COUNT=0
	ORA	E
	RZ				; YES- RETURN TO CALLER

	PUSH	H			; SAVE (DE) & (HL)
	PUSH	D

	MOV	E,M			; CHARACTER TO E
	LDA	PRINT$DEVICE		; GET CALL CODE FOR RELEVANT DEVICE
	MOV	C,A			; SET CALL CODE TO BDOS

	CALL	BDOS			; PRINT CHARACTER

	POP	D
	POP	H			; RESTORE COUNT AND POINTER

	DCX	D			; DECREMENT COUNT
	INX	H			; INCREMENT POINTER
	JMP	LOOP9			; CONTINUE FOR ALL


PAGE
	; FILE CONTROL BLOCK
	; ==== ======= =====

FCB:
DRIVE:		DB 0		; USE DEFAULT UNLESS SPECIFIED
FNAME:		DB '????????'	; WILDCARD FOR ANY FILENAME
FEXT:		DB '???'	; OR EXTENSION
	REPT 24
		DB 0
	ENDM


PAGE


	; DATA AREA
	; ==== ====

DMA$BUFF:	DS 128D		; BUFFER IS 128 BYTES LONG
OLD$STK:	DS 2		; CCP STACK POINTER SAVE AREA
		DS 100H		; NEW STACK SAVE AREA
NEW$STK:			; WHICH GOES BACKWARDS, REMEMBER.
OLD$USR:	DS 1		; USER PARTITION ON ENTRY TO THIS PROGRAM
USER$NO:	DB 0		; USER AREA UNDER SEARCH
COLUMN:		DB 0		; INITIALLY COLUMN 0 ON SCREEN
PRINT$DEVICE	DB CONOUT	; DEFAULT IS OUTPUT TO CONSOLE
BUFF$PTR:	DW BUFFER	; INITIALLY START OF BUFFER
BUFFER:		DB 0		; REST OF AVAILABLE RAM IS BUFFER

	END	100H


